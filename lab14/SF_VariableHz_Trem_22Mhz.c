//************************************************************************************
//**  
//**  Source name:   K:\dspTerm2\lab14\SF_VariableHz_Trem_22Mhz.fcfx
//**  Title:         SF_FreqGenLUT_60HzOsc_3rdInt
//**  Description:   This system runs audio at 24000 sample rate, the sample rate of the audio is determined by the highest
//**                 priority interrupt, Timer 1.
//**                 
//**                 If this is too high, the processing will get continualy interrupted resulting in system errors. You can
//**                 see this interrupt on LED D0. The length this LED is on, is proportinal to the Timer 1 ISR.
//**                 
//**                 It's important to enable 'Interrupt Nesting' NSTDIS = 0, to enable the interrupts to adopt priorities.
//**                 
//**                 Timer 2 - This controls the Lookup Table data fetch. The table will cycle at the Timer 2 rate / LUT size, in
//**                 this case 6000 / 100 = 60Hz. This can be heard on the audio output. A sinewave is held in the LUT.
//**                 
//**                 Timer 3 - This is the lowest priority interrupt and controls when the Potentiometer is read.
//**  Device:        PIC16.30F.30F4013
//**  
//**  Generated by:  Flowcode v7.2.1.4
//**  Date:          Monday, April 08, 2019 12:22:08
//**  Users:         1
//**  Registered to: University of Huddersfield
//**  Licence key:   2R5ZZ8
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC16

#define MX_CAL_PIC16

#define MX_CLK_SPEED 117920000

#define FCP_NULL Unconnected_Port

#define MX_CLKS_PER_INST 4
#define MX_SPI1CON
#define MX_30FCAN
#include <xc.h>
#include <math.h>
#include <stdlib.h>
#include "p30Fxxxx.h"
//Configuration Start
_FOSC(34583);
_FWDT(63);
_FBORPOR(34739);
_FGS(7);
_FICD(49155);
//Configuration End

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 7\CAL\internals.c"





/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_VOLTSDISPLAY 20
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT16 FCV_NEXTSINEPOINT = (0x0);
MX_GLOBAL MX_UINT8 FCV_NEXTLUT_INDEX = (0x1);
MX_GLOBAL MX_UINT16 FCV_VOLTAGEADCUI = (0x0);
MX_GLOBAL MX_UINT16 FCV_VOLUMEDIVIDER = (0x1);
MX_GLOBAL MX_BOOL FCV_DEPTHUP;
MX_GLOBAL MX_UINT16 FCV_AUDIOSIGNAL;
MX_GLOBAL MX_SINT32 FCV_LONGINTERIMAUDIO = (0);
MX_GLOBAL MX_UINT16 FCV_SINEDATA = (0x0);
MX_GLOBAL MX_UINT16 FCV_SIZEOFLUT = (0x65);
MX_GLOBAL MX_SINT16 FCV_INTERIMAUDIO;
MX_GLOBAL MX_UINT16 FCV_VOLTAGEDISPLAY = (0x1);
MX_GLOBAL MX_BOOL FCV_DEPTHDOWN = (0);
MX_GLOBAL MX_UINT32 FCV_INTTREMVALUE = (0x1);
MX_GLOBAL MX_UINT16 FCV_SINECOUNT = (0x0);
MX_GLOBAL MX_UINT32 FCV_LONGSINEDATA = (0x0);
MX_GLOBAL MX_UINT8 FCV_LUT_INDEX = (0x0);
MX_GLOBAL MX_SINT16 FCV_DEPTH = (1);
MX_GLOBAL MX_CHAR FCV_VOLTSDISPLAY[FCVsz_VOLTSDISPLAY];

void FCM_Timer1_Interrupt();
void FCM_Timer2_Interrupt();
void FCM_Timer3_Interrupt();
MX_UINT16 FCM_Read_ADC();
void FCM_Write_DAC(MX_UINT16 FCL_VALUE);

/*========================================================================*\
   Use :lut1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_lut1__FLOATFIXEDLIST 1
#define FCVsz_00fb1_lut1__INTLIST 101
#define FCVsz_00fb1_lut1__FLOATLIST 1
#define FCVsz_00fb1_lut1__INTFIXEDLIST 1
#define FCD_00fb1_lut1__INTLIST(ix) FCD_00fb1_lut1__INTLIST_LUT[ix]
ROMARRAY_(MX_SINT16) FCD_00fb1_lut1__INTLIST_LUT ROMARRAY_E =
{
// Property added elements
  0, 2058, 4107, 6140, 8149, 10126, 12063, 13952, 15786, 17558, 19261, 20887, 22431, 23887, 25248, 26510, 27667,
 28715, 29649, 30467, 31164, 31739, 32188, 32510, 32703, 32767, 32703, 32510, 32188, 31739, 31164, 30467, 29649,
 28715, 27667, 26510, 25248, 23887, 22431, 20887, 19261, 17558, 15786, 13952, 12063, 10126, 8149, 6140, 4107,
 2058, 0, -2058, -4107, -6140, -8149, -10126, -12063, -13952, -15786, -17558, -19261, -20887, -22431, -23887, -25248,
 -26510, -27667, -28715, -29649, -30467, -31164, -31739, -32188, -32510, -32703, -32768, -32703, -32510, -32188, -31739, -31164,
 -30467, -29649, -28715, -27667, -26510, -25248, -23887, -22431, -20887, -19261, -17558, -15786, -13952, -12063, -10126, -8149,
 -6140, -4107, -2058, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :InjectorBase1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_spi
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_SPI_SS_TRIS_1 tris
#define MX_SPI_MISO_PORT_1 portf
#define MX_SPI_SCK_TRIS_1 trisf
#define MX_SPI_SCK_PIN_1 (6)
#define MX_SPI_MOSI_TRIS_1 trisf
#define MX_SPI_BMODE_1 (0)
#define MX_SPI_MISO_TRIS_1 trisf
#define MX_SPI_MOSI_PIN_1 (3)
#define MX_SPI_MISO_PIN_1 (2)
#define MX_SPI_SS_PIN_1 (0)
#define MX_SPI_PR_SCALE_1 (2)
#define MX_SPI_SS_PORT_1 port
#define MX_SPI_SCK_PORT_1 portf
#define MX_SPI_MOSI_PORT_1 portf
#define MX_SPI_CHANNEL_1 (1)


/*=----------------------------------------------------------------------=*\
   Use :cal_spi
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_SPI_REF1

MX_GLOBAL MX_UINT32 FCV_01531_cal_spi__CONSOLE;

void FC_CAL_SPI_Slave_Uninit_1();
void FCD_01531_cal_spi__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_SPI_Slave_Init_1();
void FC_CAL_SPI_Master_Uninit_1();
MX_UINT8 FC_CAL_SPI_Master_Byte_1(MX_UINT8 FCL_DATAOUT);
void FC_CAL_SPI_Slave_TxByte_1(MX_UINT8 FCL_DATA);
MX_UINT8 FC_CAL_SPI_Slave_RxByte_1();
void FC_CAL_SPI_SetPrescaler_1(MX_UINT8 FCL_PRESCALER);
void FC_CAL_SPI_Master_Init_1();

/*========================================================================*\
   Use :SPI_Master1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_06c41_SPI_Master1__SendString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FCD_06c41_SPI_Master1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES, MX_UINT8 FCL_CH);
void FCD_06c41_SPI_Master1__SendChar(MX_UINT8 FCL_CHAR);
MX_UINT8 FCD_06c41_SPI_Master1__GetChar();
void FCD_06c41_SPI_Master1__UnInitialise();
void FCD_06c41_SPI_Master1__Initialise();

/*========================================================================*\
   Use :ctrl_lcd
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__RemapCharacter FCD_04071_LCD__RemapCharacter
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_1_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_1_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_9 
#define MX_ADC_TYPE_6 
#define ADC_1_MX_ADC_VREFOP 0
#define ADC_1_MX_ADC_CONVSP 3
#define MX_ADC_BITS_12 
#define ADC_1_MX_ADC_CHANNEL 9

#define FCV_0aae1_cal_adc__FALSE (0)
#define FCV_0aae1_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt();
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f41_adc_base__GetVoltage();
void FCD_08f41_adc_base__RawEnable();
MX_UINT8 FCD_08f41_adc_base__RawSampleByte();
MX_UINT16 FCD_08f41_adc_base__GetInt();
void FCD_08f41_adc_base__RawDisable();
MX_UINT8 FCD_08f41_adc_base__GetByte();

/*========================================================================*\
   Use :pot_color_cap1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03521_pot_color_cap1__RawSampleInt FCD_08f41_adc_base__RawSampleInt
#define FCD_03521_pot_color_cap1__RawAverageByte FCD_08f41_adc_base__RawAverageByte
#define FCD_03521_pot_color_cap1__GetString FCD_08f41_adc_base__GetString
#define FCD_03521_pot_color_cap1__GetAverageByte FCD_08f41_adc_base__GetAverageByte
#define FCD_03521_pot_color_cap1__RawAverageInt FCD_08f41_adc_base__RawAverageInt
#define FCD_03521_pot_color_cap1__GetAverageInt FCD_08f41_adc_base__GetAverageInt
#define FCD_03521_pot_color_cap1__GetVoltage FCD_08f41_adc_base__GetVoltage
#define FCD_03521_pot_color_cap1__RawEnable FCD_08f41_adc_base__RawEnable
#define FCD_03521_pot_color_cap1__RawSampleByte FCD_08f41_adc_base__RawSampleByte
#define FCD_03521_pot_color_cap1__GetInt FCD_08f41_adc_base__GetInt
#define FCD_03521_pot_color_cap1__RawDisable FCD_08f41_adc_base__RawDisable
#define FCD_03521_pot_color_cap1__GetByte FCD_08f41_adc_base__GetByte

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 7\CAL\includes.c"


/*========================================================================*\
   Use :lut1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_spi
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Send text to the SPI console
       :
       :Parameters for macro Prv_TextConsole:
       :  str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_01531_cal_spi__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :SPI_Master1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sends a string of bytes to the SPI bus
       :
       :Parameters for macro SendString:
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__SendString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{
	//Local variable definitions
	MX_UINT8 FCL_CH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_LEN;


	FCL_LEN = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
	FCL_IDX = 0;

	while (FCL_IDX < FCL_LEN)
	{

		FC_CAL_SPI_Master_Byte_1(FCL_STR[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to read a string of bytes from the SPI bus.
       :
       :Parameters for macro GetString:
       :  NumBytes : MX_UINT8
       :  Ch : MX_UINT8
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES, MX_UINT8 FCL_CH)
{
	//Local variable definitions


	FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

	while (FCL_NUMBYTES)
	{

		FCL_CH = FC_CAL_SPI_Master_Byte_1(0x55);

		FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, &FCL_CH,1, FCR_RETVAL,20);

		FCL_NUMBYTES = FCL_NUMBYTES - 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :General purpose SPI send byte macro
       :
       :Parameters for macro SendChar:
       :  Char : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__SendChar(MX_UINT8 FCL_CHAR)
{

	FC_CAL_SPI_Master_Byte_1(FCL_CHAR);

}

/*=----------------------------------------------------------------------=*\
   Use :General purpose SPI get byte macro
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_06c41_SPI_Master1__GetChar()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_SPI_Master_Byte_1(0x55);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Deactivates the SPI peripheral leaving the I/O pins in a state where they can be used for general purpose I/O.
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__UnInitialise()
{

	FC_CAL_SPI_Master_Uninit_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Activates the SPI peripheral and claims control over the I/O pins.
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__Initialise()
{

	FC_CAL_SPI_Master_Init_1();

}


/*========================================================================*\
   Use :ctrl_lcd
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()
{




	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Local variable definitions
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;


	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		#else


			FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		#endif

		FCL_IDX = FCL_IDX + 1;


	}


}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Local variable definitions
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Local variable definitions
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 2 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
		{

			FCL_Y = 0x80;

		} else {

			FCL_Y = 0xC0;

		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 2 == 4

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Parameters for macro Command:
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Local variable definitions
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Parameters for macro ScrollDisplay:
       :  Position : Holds the number of positions to shift the display
       :  Direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Local variable definitions
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	if (FCL_DIRECTION == 0)
	{

		FCL_CMD = 0x18;


	} else {

		FCL_CMD = 0x1C;


	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
	//Local variable definitions
	MX_UINT8 FCL_NIBBLE;


	//Comment:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, D, 0x1, 0x0, 0);
		FCP_SET(B, D, 0x2, 0x1, 0);
		FCP_SET(B, D, 0x4, 0x2, 0);
		FCP_SET(B, D, 0x8, 0x3, 0);
		FCP_SET(B, D, 0x100, 0x8, 0);
		FCP_SET(B, D, 0x200, 0x9, 0);

		#if (0)

		//Code has been optimised out by the pre-processor
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
		FCP_SET(B, D, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x8, 0x3, (FCL_NIBBLE & 0x01));

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	//Comment:
	//Output byte to pins

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	//Comment:
	//Output byte to port

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	if (FCL_TYPE)
	{

		FCP_SET(B, D, 0x100, 0x8, 1);

	// } else {

	}

	FCI_DELAYBYTE_US(100);

	//Comment:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, D, 0x200, 0x9, 1);

	FCI_DELAYBYTE_US(100);

	FCP_SET(B, D, 0x200, 0x9, 0);

	FCI_DELAYBYTE_US(100);

	#if (1) // 0 == 0

		FCP_SET(B, D, 0x1, 0x0, 0);
		FCP_SET(B, D, 0x2, 0x1, 0);
		FCP_SET(B, D, 0x4, 0x2, 0);
		FCP_SET(B, D, 0x8, 0x3, 0);
		FCP_SET(B, D, 0x100, 0x8, 0);

		FCL_NIBBLE = (FCL_DATA & 0xf);
		FCP_SET(B, D, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x8, 0x3, (FCL_NIBBLE & 0x01));

		if (FCL_TYPE)
		{

			FCP_SET(B, D, 0x100, 0x8, 1);

		// } else {

		}

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, D, 0x200, 0x9, 1);

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, D, 0x200, 0x9, 0);

		FCI_DELAYBYTE_US(100);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a remap character allowing the PrintString function to automatically swap between pre-defined characters. 
       :The characters can be custom (in the range 0-9) or can point to an existing character in the LCD character map.
       :
       :Parameters for macro RemapCharacter:
       :  RemapIdx : Remap Index, Range: 0 to (Remap Characters - 1)
       :  SearchCharacter : Character to look for a replace
       :  ReplacementCharacter : New character value to use in place of the search character.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{




	#if (1) // 0 == 0

		FCP_SET(B, D, 0x1, 0x0, 0);
		FCP_SET(B, D, 0x2, 0x1, 0);
		FCP_SET(B, D, 0x4, 0x2, 0);
		FCP_SET(B, D, 0x8, 0x3, 0);
		FCP_SET(B, D, 0x100, 0x8, 0);
		FCP_SET(B, D, 0x200, 0x9, 0);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}


/*========================================================================*\
   Use :lcd_eb005
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f41_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL, FCRsz_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f41_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.001221);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(9, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :pot_color_cap1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Timer1_Interrupt()
{

	// Output
	// Output: 1 -> B0
	FCP_SET(M, B, 0x0001, 0, (1));
	// Call Macro
	// Call Macro: AudioSignal=Read_ADC()
	FCV_AUDIOSIGNAL = FCM_Read_ADC();

	// Calculation
	// Calculation:
	//  InterimAudio = AudioSignal - 32768
	FCV_INTERIMAUDIO = FCV_AUDIOSIGNAL - 32768;

	// C Code
	// C Code:
	//Tremolo
	CORCONbits.IF = 0; //fractional mode
	volatile register int A asm("A");
	volatile register int B asm("B");
	asm("MOV.W _FCV_INTERIMAUDIO, W4");
	asm("MOV.W _FCV_INTTREMVALUE, W5");
	asm("MOV.W _FCV_DEPTH, W6");
	asm("MPY W5*W6, B");
	asm("SAC B, W7");
	asm("MPY W4*W7, A");
	FCV_INTERIMAUDIO = __builtin_ACCH(A);
	CORCONbits.IF = 1; //integer mode

	// Calculation
	// Calculation:
	//  SineData = InterimAudio + 32768
	FCV_SINEDATA = FCV_INTERIMAUDIO + 32768;

	// Call Macro
	// Call Macro: Write_DAC(SineData)
	FCM_Write_DAC(FCV_SINEDATA);

	// Output
	// Output: 0 -> B0
	FCP_SET(M, B, 0x0001, 0, (0));
}

/*=----------------------------------------------------------------------=*\
   Use :LFO
\*=----------------------------------------------------------------------=*/
void FCM_Timer2_Interrupt()
{

	// Output
	// Output: 1 -> B1
	FCP_SET(M, B, 0x0002, 1, (1));
	// C Code
	// C Code:
	/*
	  Enter C code below this comment
	*/
	FCV_LUT_INDEX = (FCV_LUT_INDEX+FCV_VOLUMEDIVIDER)%FCV_SIZEOFLUT;

	// Calculation
	// Calculation:
	//  IntTremValue = lut1 :: GetInt (LUT_index)
	FCV_INTTREMVALUE = FCD_00fb1_lut1__INTLIST(FCV_LUT_INDEX);

	// Output
	// Output: 0 -> B1
	FCP_SET(M, B, 0x0002, 1, (0));
}

/*=----------------------------------------------------------------------=*\
   Use :Grab the control knob value!
\*=----------------------------------------------------------------------=*/
void FCM_Timer3_Interrupt()
{

	// Output
	// Output: 1 -> B2
	FCP_SET(M, B, 0x0004, 2, (1));
	// Call Component Macro
	// Call Component Macro: VoltageADCUI=pot_color_cap1::RawSampleInt()
	FCV_VOLTAGEADCUI = FCD_03521_pot_color_cap1__RawSampleInt();

	// Calculation
	// Calculation:
	//  voltageADCUI = voltageADCUI >> 9
	//  voltageADCUI = voltageADCUI + 1
	FCV_VOLTAGEADCUI = FCV_VOLTAGEADCUI >> 9;
	FCV_VOLTAGEADCUI = FCV_VOLTAGEADCUI + 1;

	// VoltageDisplay
	// Decision: VoltageDisplay != VoltageADCUI?
	if (FCV_VOLTAGEDISPLAY != FCV_VOLTAGEADCUI)
	{

		// Calculation
		// Calculation:
		//  VoltageDisplay = VoltageADCUI
		FCV_VOLTAGEDISPLAY = FCV_VOLTAGEADCUI;

		// Call Component Macro
		// Call Component Macro: lcd_eb005::Cursor(0, 20)
		FCD_0ad31_lcd_eb005__Cursor(0, 20);

		// Call Component Macro
		// Call Component Macro: lcd_eb005::ClearLine(1)
		FCD_0ad31_lcd_eb005__ClearLine(1);

		// Call Component Macro
		// Call Component Macro: lcd_eb005::PrintNumber(voltageDisplay)
		FCD_0ad31_lcd_eb005__PrintNumber(FCV_VOLTAGEDISPLAY);

	// } else {

	}

	// Output
	// Output: 0 -> B2
	FCP_SET(M, B, 0x0004, 2, (0));
}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCM_Read_ADC()
{
	//Local variable definitions
	MX_UINT8 FCL_UPPER;
	MX_UINT8 FCL_MID;
	MX_UINT8 FCL_LOWER;
	MX_UINT16 FCR_RETVAL;


	// Output
	// Output: 0 -> F0
	FCP_SET(M, F, 0x0001, 0, (0));
	// Call Component Macro
	// Call Component Macro: .upper=SPI_Master1::GetChar()
	FCL_UPPER = FCD_06c41_SPI_Master1__GetChar();

	// Call Component Macro
	// Call Component Macro: .mid=SPI_Master1::GetChar()
	FCL_MID = FCD_06c41_SPI_Master1__GetChar();

	// Call Component Macro
	// Call Component Macro: .lower=SPI_Master1::GetChar()
	FCL_LOWER = FCD_06c41_SPI_Master1__GetChar();

	// Output
	// Output: 1 -> F0
	FCP_SET(M, F, 0x0001, 0, (1));
	// Calculation
	// Calculation:
	//  .Return = .upper << 12
	//  .Return = .Return | (.mid << 4)
	//  .Return = .Return | (.lower >> 4)
	FCR_RETVAL = FCL_UPPER << 12;
	FCR_RETVAL = FCR_RETVAL | (FCL_MID << 4);
	FCR_RETVAL = FCR_RETVAL | (FCL_LOWER >> 4);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Write_DAC:
       :  value : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCM_Write_DAC(MX_UINT16 FCL_VALUE)
{
	//Local variable definitions
	MX_UINT8 FCL_UPPER;
	MX_UINT8 FCL_LOWER;


	// Calculation
	// Calculation:
	//  .upper = .value >> 8
	//  .lower = .value
	FCL_UPPER = FCL_VALUE >> 8;
	FCL_LOWER = FCL_VALUE;

	// Output
	// Output: 0 -> F1
	FCP_SET(M, F, 0x0002, 1, (0));
	// Call Component Macro
	// Call Component Macro: SPI_Master1::SendChar(0x00)
	FCD_06c41_SPI_Master1__SendChar(0x00);

	// Call Component Macro
	// Call Component Macro: SPI_Master1::SendChar(.upper)
	FCD_06c41_SPI_Master1__SendChar(FCL_UPPER);

	// Call Component Macro
	// Call Component Macro: SPI_Master1::SendChar(.lower)
	FCD_06c41_SPI_Master1__SendChar(FCL_LOWER);

	// Output
	// Output: 1 -> F1
	FCP_SET(M, F, 0x0002, 1, (1));
}



/*========================================================================*\
   Use :Main
\*========================================================================*/
int main()
{
ADPCFG = 0xffff;


	// Call Component Macro
	// Call Component Macro: pot_color_cap1::RawEnable()
	FCD_03521_pot_color_cap1__RawEnable();

	// Call Component Macro
	// Call Component Macro: SPI_Master1::Initialise()
	FCD_06c41_SPI_Master1__Initialise();

	// Call Component Macro
	// Call Component Macro: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();

	// Call Component Macro
	// Call Component Macro: lcd_eb005::PrintString("Voltage ADC")
	FCD_0ad31_lcd_eb005__PrintString("Voltage ADC", 12);

	// Calculation
	// Calculation:
	//  LUT_index = 0
	FCV_LUT_INDEX = 0;

	// C Code
	// C Code:
	/*
	  Enter C code below this comment
	*/
	INTCON1bits.NSTDIS = 1;
	/* Make highest Priority */
	IPC0bits.T1IP0 = 1;
	IPC0bits.T1IP1 = 1;
	IPC0bits.T1IP2 = 1;

	/* Make Lowest Priority */

	IPC1bits.T2IP0 = 1;
	IPC1bits.T2IP1 = 1;
	IPC1bits.T2IP2 = 0;

	IPC1bits.T3IP0 = 1;
	IPC1bits.T3IP1 = 0;
	IPC1bits.T3IP2 = 0;

	/*Enable Nesting */
	INTCON1bits.NSTDIS = 0;


	// Interrupt
	// Interrupt: Enable TMR1
	T1CON = ((T1CON & 0xfffd) | 0x8000);
	T1CON &= 0xff0f;
	PR1=614-1;
	IEC0bits.T1IE = 1;

	// Interrupt
	// Interrupt: Enable TMR2
	T2CON = ((T2CON & 0xfffd) | 0x8000);
	T2CON = ((T2CON & 0xff0f) | 0x0020);
	PR2=7400-1;
	IEC0bits.T2IE = 1;

	// Interrupt
	// Interrupt: Enable TMR3
	T3CON = ((T3CON & 0xfffd) | 0x8000);
	T3CON = ((T3CON & 0xff0f) | 0x0030);
	PR3=10000-1;
	IEC0bits.T3IE = 1;

	// Loop
	// Loop: While 1
	while (1)
	{

		// Input
		// Input: B7 -> depthUP
		FCV_DEPTHUP = FCP_GET(B, B, 0x0080, 7);
		// Input
		// Input: B6 -> depthDown
		FCV_DEPTHDOWN = FCP_GET(B, B, 0x0040, 6);
		// Decision
		// Decision: depthUP?
		if (FCV_DEPTHUP)
		{

			// Decision
			// Decision: depth < 32667?
			if (FCV_DEPTH < 32667)
			{

				// Calculation
				// Calculation:
				//  Depth = Depth + 100
				FCV_DEPTH = FCV_DEPTH + 100;

				// Call Component Macro
				// Call Component Macro: lcd_eb005::Cursor(0, 20)
				FCD_0ad31_lcd_eb005__Cursor(0, 20);

				// Call Component Macro
				// Call Component Macro: lcd_eb005::PrintNumber(depth)
				FCD_0ad31_lcd_eb005__PrintNumber(FCV_DEPTH);

			// } else {

			}

		} else {

			// Decision
			// Decision: depthDown?
			if (FCV_DEPTHDOWN)
			{

				// Decision
				// Decision: depth > 100?
				if (FCV_DEPTH > 100)
				{

					// Calculation
					// Calculation:
					//  Depth = Depth - 100
					FCV_DEPTH = FCV_DEPTH - 100;

					// Call Component Macro
					// Call Component Macro: lcd_eb005::Cursor(0, 20)
					FCD_0ad31_lcd_eb005__Cursor(0, 20);

					// Call Component Macro
					// Call Component Macro: lcd_eb005::PrintNumber(depth)
					FCD_0ad31_lcd_eb005__PrintNumber(FCV_DEPTH);

				// } else {

				}

			// } else {

			}

		}


	}

	mainendloop: goto mainendloop;
	return 0;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/

	//Handler code for [TMR1]
	#ifndef MX_ISR_T1
	#define MX_ISR_T1
	void _ISR _T1Interrupt(void)
	{
		IFS0bits.T1IF = 0;
		FCM_Timer1_Interrupt();
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <Timer1_Interrupt> may never get called."
	#endif


	//Handler code for [TMR2]
	#ifndef MX_ISR_T2
	#define MX_ISR_T2
	void _ISR _T2Interrupt(void)
	{
		IFS0bits.T2IF = 0;
		FCM_Timer2_Interrupt();
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <Timer2_Interrupt> may never get called."
	#endif


	//Handler code for [TMR3]
	#ifndef MX_ISR_T3
	#define MX_ISR_T3
	void _ISR _T3Interrupt(void)
	{
		IFS0bits.T3IF = 0;
		FCM_Timer3_Interrupt();
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <Timer3_Interrupt> may never get called."
	#endif





