//************************************************************************************
//**  
//**  Source name:   K:\dspTerm2\Assignment\assignmentu1453415.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC16.30F.30F4013
//**  
//**  Generated by:  Flowcode v7.2.1.4
//**  Date:          Wednesday, April 17, 2019 14:04:26
//**  Users:         1
//**  Registered to: University of Huddersfield
//**  Licence key:   2R5ZZ8
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC16

#define MX_CAL_PIC16

#define MX_CLK_SPEED 117920000

#define FCP_NULL Unconnected_Port

#define MX_CLKS_PER_INST 4
#define MX_SPI1CON
#define MX_30FCAN
#include <xc.h>
#include <math.h>
#include <stdlib.h>
#include "p30Fxxxx.h"
//Configuration Start
_FOSC(34583);
_FWDT(63);
_FBORPOR(34739);
_FGS(7);
_FICD(49155);
//Configuration End

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 7\CAL\internals.c"





/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_CHORUSINDEX 4
#define FCVsz_WAHB_FLOAT 2
#define FCVsz_CHORUSSAMPLEDELAYVOICE 4
#define FCVsz_WAHXFIXED 4
#define FCVsz_CIRCULARBUFFER 700
#define FCVsz_WAHA_FLOAT 2
#define FCVsz_WAHBUFFER 4
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_SINT16 FCV_FRACTREM = (341);
MX_GLOBAL MX_UINT16 FCV_VOLTAGE;
MX_GLOBAL MX_SINT16 FCV_FRAC = (341);
MX_GLOBAL MX_UINT16 FCV_PERIODCOUNT = (0x64);
MX_GLOBAL MX_UINT16 FCV_VOLTAGEADC = (0x1);
MX_GLOBAL MX_BOOL FCV_ISB1DOWN = (0);
MX_GLOBAL MX_FLOAT FCV_WAHFC = (0.0);
MX_GLOBAL MX_SINT32 FCV_CHORUSVOICESUMLONG = (0);
MX_GLOBAL MX_UINT16 FCV_FLANGERDEPTH = (0x13ec);
MX_GLOBAL MX_UINT16 FCV_VIBRATOLUTVAL = (0x1);
MX_GLOBAL MX_UINT16 FCV_VIBRATODEPTH = (0x13ec);
MX_GLOBAL MX_SINT16 FCV_AUDIOHOLDB = (0);
MX_GLOBAL MX_UINT16 FCV_LUTOFFSET = (0x1);
MX_GLOBAL MX_BOOL FCV_ISB2DOWN = (0);
MX_GLOBAL MX_BOOL FCV_UPDOWNSWITCHSTATE = (0);
MX_GLOBAL MX_UINT16 FCV_BITCRUSHERADC = (0x0);
MX_GLOBAL MX_SINT16 FCV_AUDIOHOLDA = (0);
MX_GLOBAL MX_UINT16 FCV_CIRCULARBUFFERINDEX = (0x0);
MX_GLOBAL MX_UINT8 FCV_PARAMNUMBER = (0x1); // number of parameters on current effect
MX_GLOBAL MX_UINT16 FCV_CHORUSINDEX[FCVsz_CHORUSINDEX];
MX_GLOBAL MX_SINT16 FCV_CHORUSLUTTARGETVAL = (0);
MX_GLOBAL MX_BOOL FCV_ISB3DOWN = (0);
MX_GLOBAL MX_SINT16 FCV_CHORUSVOICESUM;
MX_GLOBAL MX_UINT8 FCV_VIBRATODEPTHDISPLAY = (0x32);
MX_GLOBAL MX_UINT8 FCV_FX3COUNTER = (0x0);
MX_GLOBAL MX_UINT16 FCV_VIBRATOLUTTARGET = (0x0);
MX_GLOBAL MX_UINT8 FCV_CHORUSINDEXITERATOR = (0x0);
MX_GLOBAL MX_UINT8 FCV_CHORUSNUMVOICES = (0x2);
MX_GLOBAL MX_SINT16 FCV_LUTVAL = (1);
MX_GLOBAL MX_BOOL FCV_ISB4DOWN = (0);
MX_GLOBAL MX_FLOAT FCV_WAHNORM = (0.0);
MX_GLOBAL MX_FLOAT FCV_WAHB_FLOAT[FCVsz_WAHB_FLOAT];
MX_GLOBAL MX_UINT16 FCV_DISTORTIONGAIN = (0x3e8);
MX_GLOBAL MX_SINT16 FCV_DISTORTIONBIASDISPLAY = (0);
MX_GLOBAL MX_UINT16 FCV_CHORUSSAMPLEDELAYVOICE[FCVsz_CHORUSSAMPLEDELAYVOICE];
MX_GLOBAL MX_SINT16 FCV_LUTCURRENT = (0);
MX_GLOBAL MX_SINT16 FCV_WAHXFIXED[FCVsz_WAHXFIXED];
MX_GLOBAL MX_UINT8 FCV_FLANGERDEPTHDISPLAY = (0x32);
MX_GLOBAL MX_UINT16 FCV_AUDIOSIGNAL;
MX_GLOBAL MX_BOOL FCV_FXBANKSWITCHSTATE = (0);
MX_GLOBAL MX_SINT16 FCV_SINEDATA;
MX_GLOBAL MX_BOOL FCV_ISB5DOWN = (0);
MX_GLOBAL MX_SINT16 FCV_CIRCULARBUFFER[FCVsz_CIRCULARBUFFER];
MX_GLOBAL MX_UINT8 FCV_PARAMCOUNTER = (0x0);
MX_GLOBAL MX_SINT16 FCV_WAHXINT = (0);
MX_GLOBAL MX_FLOAT FCV_WAHQ = (0.0);
MX_GLOBAL MX_FLOAT FCV_WAHA_FLOAT[FCVsz_WAHA_FLOAT];
MX_GLOBAL MX_SINT16 FCV_DISTORTIONGAINDISPLAY = (10);
MX_GLOBAL MX_BOOL FCV_ISFX4 = (0); // effect bank 4
MX_GLOBAL MX_UINT16 FCV_NOISECOUNTER = (0x0);
MX_GLOBAL MX_SINT16 FCV_FLANGERLUTVAL = (0);
MX_GLOBAL MX_BOOL FCV_ISFX3 = (0); // is effect bank 3 on
MX_GLOBAL MX_UINT16 FCV_CIRCULARBUFFERSIZE = (0x2bc);
MX_GLOBAL MX_SINT16 FCV_LUTTARGET = (1);
MX_GLOBAL MX_UINT16 FCV_WAHADC = (0x3e8);
MX_GLOBAL MX_BOOL FCV_ISB6DOWN = (0);
MX_GLOBAL MX_BOOL FCV_ISFX2 = (1); // is effect bank 2 on
MX_GLOBAL MX_UINT16 FCV_SIZEOFLUT = (0xfa);
MX_GLOBAL MX_SINT16 FCV_SIGNEDAUDIO = (0);
MX_GLOBAL MX_BOOL FCV_ISFX1 = (0); // is bank 1 on
MX_GLOBAL MX_SINT16 FCV_WAHBUFFER[FCVsz_WAHBUFFER];
MX_GLOBAL MX_UINT16 FCV_BITCRUSHERRESOLUTION = (0x10);
MX_GLOBAL MX_SINT16 FCV_DISPLAYVALUE = (0);
MX_GLOBAL MX_BOOL FCV_ISFX0 = (0); // is bank 0 on
MX_GLOBAL MX_UINT8 FCV_FX2COUNTER = (0x0);
MX_GLOBAL MX_SINT16 FCV_FLANGEDSIGNAL = (0);
MX_GLOBAL MX_UINT8 FCV_WETDRYDISPLAY = (0x32);
MX_GLOBAL MX_FLOAT FCV_WAHXFLOAT = (0.0);
MX_GLOBAL MX_SINT32 FCV_DISTORTIONLONG;
MX_GLOBAL MX_UINT16 FCV_VOLTAGEDISPLAY;
MX_GLOBAL MX_BOOL FCV_ISB7DOWN = (0);
MX_GLOBAL MX_BOOL FCV_B5SWITCHSTATE = (0);
MX_GLOBAL MX_UINT16 FCV_FLANGERINDEX = (0x0);
MX_GLOBAL MX_UINT16 FCV_VIBRATOINDEX;
MX_GLOBAL MX_UINT16 FCV_WAHHOLDB = (0x0);
MX_GLOBAL MX_SINT16 FCV_WETDRY = (16380);
MX_GLOBAL MX_FLOAT FCV_WAHLITTLEQ = (0.0);
MX_GLOBAL MX_SINT16 FCV_DISTORTIONRAILSDISPLAY = (100);
MX_GLOBAL MX_UINT16 FCV_BITCRUSHERSAMPLECOUNTER = (0x0);
MX_GLOBAL MX_SINT16 FCV_WAHHOLDA = (0);
MX_GLOBAL MX_SINT16 FCV_LUT_INDEX = (0);
MX_GLOBAL MX_SINT16 FCV_FRACINIT = (341); // fractional value based on two timers
MX_GLOBAL MX_UINT8 FCV_FX1COUNTER = (0x0);
MX_GLOBAL MX_SINT16 FCV_CHORUSLUTVAL = (0);
MX_GLOBAL MX_UINT16 FCV_FREQDIVIDER = (0x0);
MX_GLOBAL MX_SINT16 FCV_DISTORTIONBIAS = (0);
MX_GLOBAL MX_SINT16 FCV_DISTORTIONRAILS = (32760);
MX_GLOBAL MX_UINT16 FCV_CHORUSLUTINDEX = (0x0);
MX_GLOBAL MX_SINT16 FCV_FLANGERLUTTARGET = (1);
MX_GLOBAL MX_BOOL FCV_ISB0DOWN = (0);
MX_GLOBAL MX_UINT8 FCV_FX0COUNTER = (0x0);
MX_GLOBAL MX_UINT16 FCV_WAHQDAMPERINT = (0x14);
MX_GLOBAL MX_SINT16 FCV_WAHOUT = (0);

void FCM_Timer1_Interrupt();
void FCM_Timer2_Interrupt();
void FCM_timer3_interrupt();
void FCM_ButtonInterrupt();
void FCM_buttonReadIn();
MX_UINT16 FCM_Read_ADC();
void FCM_Write_DAC(MX_UINT16 FCL_VALUE);

/*========================================================================*\
   Use :lutFilteredNoise
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb2_lutFilteredNoise__FLOATFIXEDLIST 1
#define FCVsz_00fb2_lutFilteredNoise__INTLIST 250
#define FCVsz_00fb2_lutFilteredNoise__FLOATLIST 1
#define FCVsz_00fb2_lutFilteredNoise__INTFIXEDLIST 1
#define FCD_00fb2_lutFilteredNoise__INTLIST(ix) FCD_00fb2_lutFilteredNoise__INTLIST_LUT[ix]
ROMARRAY_(MX_SINT16) FCD_00fb2_lutFilteredNoise__INTLIST_LUT ROMARRAY_E =
{
// Property added elements
  0, 1, 4, 6, 8, 10, 11, 13, 14, 14, 14, 13, 13, 13, 13, 13, 15,
 16, 17, 18, 19, 19, 19, 19, 19, 18, 17, 15, 14, 13, 13, 13, 13,
 13, 12, 11, 11, 13, 14, 14, 15, 14, 14, 13, 13, 13, 14, 15, 15,
 16, 17, 19, 20, 21, 21, 21, 22, 22, 23, 22, 22, 21, 20, 19, 17,
 16, 14, 13, 11, 9, 8, 6, 3, 1, -2, -6, -10, -13, -17, -20, -23,
 -25, -26, -28, -29, -29, -29, -30, -30, -31, -32, -33, -34, -34, -34, -35, -38,
 -40, -42, -44, -46, -48, -51, -52, -53, -55, -57, -60, -63, -64, -65, -67, -68,
 -70, -72, -74, -77, -80, -82, -85, -88, -90, -92, -94, -94, -95, -95, -97, -99,
 -100, -100, -99, -98, -98, -98, -96, -95, -95, -94, -94, -94, -93, -92, -90, -88,
 -86, -86, -85, -84, -82, -80, -79, -77, -75, -72, -69, -67, -66, -64, -63, -62,
 -61, -59, -57, -56, -55, -56, -57, -58, -58, -58, -56, -54, -52, -49, -46, -43,
 -40, -37, -34, -32, -30, -28, -26, -25, -24, -23, -21, -19, -16, -14, -12, -9,
 -7, -4, -2, 0, 2, 3, 5, 5, 6, 7, 6, 6, 6, 7, 8, 10,
 13, 16, 18, 20, 22, 23, 24, 26, 28, 30, 32, 33, 35, 36, 37, 38,
 40, 42, 44, 46, 49, 53, 55, 58, 61, 64, 68, 72, 75, 78, 79, 79,
 78, 77, 76, 74, 74, 74, 75, 75, 75
// Dynamically added elements
 
};


/*========================================================================*\
   Use :lut1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_lut1__FLOATFIXEDLIST 1
#define FCVsz_00fb1_lut1__INTLIST 250
#define FCVsz_00fb1_lut1__FLOATLIST 1
#define FCVsz_00fb1_lut1__INTFIXEDLIST 1
#define FCD_00fb1_lut1__INTLIST(ix) FCD_00fb1_lut1__INTLIST_LUT[ix]
ROMARRAY_(MX_SINT16) FCD_00fb1_lut1__INTLIST_LUT ROMARRAY_E =
{
// Property added elements
  0, 827, 1653, 2478, 3302, 4123, 4942, 5758, 6570, 7378, 8181, 8979, 9771, 10557, 11337, 12109, 12873,
 13629, 14377, 15115, 15844, 16563, 17271, 17968, 18654, 19327, 19989, 20638, 21273, 21895, 22503, 23097, 23676,
 24240, 24789, 25322, 25838, 26339, 26822, 27289, 27738, 28169, 28582, 28978, 29354, 29712, 30052, 30372, 30672,
 30953, 31215, 31457, 31678, 31879, 32061, 32221, 32361, 32481, 32580, 32658, 32715, 32752, 32767, 32762, 32736,
 32689, 32621, 32533, 32424, 32294, 32143, 31973, 31781, 31570, 31338, 31087, 30815, 30524, 30214, 29884, 29536,
 29168, 28782, 28378, 27956, 27515, 27058, 26583, 26091, 25582, 25057, 24517, 23960, 23389, 22802, 22201, 21586,
 20957, 20315, 19660, 18992, 18312, 17621, 16918, 16205, 15481, 14747, 14004, 13252, 12492, 11724, 10948, 10165,
 9376, 8581, 7780, 6975, 6164, 5351, 4533, 3713, 2890, 2066, 1240, 413, 413, 1240, 2066, 2890,
 3713, 4533, 5351, 6164, 6975, 7780, 8581, 9376, 10165, 10948, 11724, 12492, 13252, 14004, 14747, 15481,
 16205, 16918, 17621, 18312, 18992, 19660, 20315, 20957, 21586, 22201, 22802, 23389, 23960, 24517, 25057, 25582,
 26091, 26583, 27058, 27515, 27956, 28378, 28782, 29168, 29536, 29884, 30214, 30524, 30815, 31087, 31338, 31570,
 31781, 31973, 32143, 32294, 32424, 32533, 32621, 32689, 32736, 32762, 32767, 32752, 32715, 32658, 32580, 32481,
 32361, 32221, 32061, 31879, 31678, 31457, 31215, 30953, 30672, 30372, 30052, 29712, 29354, 28978, 28582, 28169,
 27738, 27289, 26822, 26339, 25838, 25322, 24789, 24240, 23676, 23097, 22503, 21895, 21273, 20638, 19989, 19327,
 18654, 17968, 17271, 16563, 15844, 15115, 14377, 13629, 12873, 12109, 11337, 10557, 9771, 8979, 8181, 7378,
 6570, 5758, 4942, 4123, 3302, 2478, 1653, 827, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :InjectorBase1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_spi
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_SPI_SS_TRIS_1 tris
#define MX_SPI_MISO_PORT_1 portf
#define MX_SPI_SCK_TRIS_1 trisf
#define MX_SPI_SCK_PIN_1 (6)
#define MX_SPI_MOSI_TRIS_1 trisf
#define MX_SPI_BMODE_1 (0)
#define MX_SPI_MISO_TRIS_1 trisf
#define MX_SPI_MOSI_PIN_1 (3)
#define MX_SPI_MISO_PIN_1 (2)
#define MX_SPI_SS_PIN_1 (0)
#define MX_SPI_PR_SCALE_1 (2)
#define MX_SPI_SS_PORT_1 port
#define MX_SPI_SCK_PORT_1 portf
#define MX_SPI_MOSI_PORT_1 portf
#define MX_SPI_CHANNEL_1 (1)


/*=----------------------------------------------------------------------=*\
   Use :cal_spi
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_SPI_REF1

MX_GLOBAL MX_UINT32 FCV_01531_cal_spi__CONSOLE;

void FC_CAL_SPI_Slave_Uninit_1();
void FCD_01531_cal_spi__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_SPI_Slave_Init_1();
void FC_CAL_SPI_Master_Uninit_1();
MX_UINT8 FC_CAL_SPI_Master_Byte_1(MX_UINT8 FCL_DATAOUT);
void FC_CAL_SPI_Slave_TxByte_1(MX_UINT8 FCL_DATA);
MX_UINT8 FC_CAL_SPI_Slave_RxByte_1();
void FC_CAL_SPI_SetPrescaler_1(MX_UINT8 FCL_PRESCALER);
void FC_CAL_SPI_Master_Init_1();

/*========================================================================*\
   Use :SPI_Master1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_06c41_SPI_Master1__SendString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FCD_06c41_SPI_Master1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES, MX_UINT8 FCL_CH);
void FCD_06c41_SPI_Master1__SendChar(MX_UINT8 FCL_CHAR);
MX_UINT8 FCD_06c41_SPI_Master1__GetChar();
void FCD_06c41_SPI_Master1__UnInitialise();
void FCD_06c41_SPI_Master1__Initialise();

/*========================================================================*\
   Use :ctrl_lcd
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__RemapCharacter FCD_04071_LCD__RemapCharacter
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_1_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_1_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_9 
#define MX_ADC_TYPE_6 
#define ADC_1_MX_ADC_VREFOP 0
#define ADC_1_MX_ADC_CONVSP 3
#define MX_ADC_BITS_12 
#define ADC_1_MX_ADC_CHANNEL 9

#define FCV_0aae1_cal_adc__FALSE (0)
#define FCV_0aae1_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt();
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f41_adc_base__GetVoltage();
void FCD_08f41_adc_base__RawEnable();
MX_UINT8 FCD_08f41_adc_base__RawSampleByte();
MX_UINT16 FCD_08f41_adc_base__GetInt();
void FCD_08f41_adc_base__RawDisable();
MX_UINT8 FCD_08f41_adc_base__GetByte();

/*========================================================================*\
   Use :pot_color_cap1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03521_pot_color_cap1__RawSampleInt FCD_08f41_adc_base__RawSampleInt
#define FCD_03521_pot_color_cap1__RawAverageByte FCD_08f41_adc_base__RawAverageByte
#define FCD_03521_pot_color_cap1__GetString FCD_08f41_adc_base__GetString
#define FCD_03521_pot_color_cap1__GetAverageByte FCD_08f41_adc_base__GetAverageByte
#define FCD_03521_pot_color_cap1__RawAverageInt FCD_08f41_adc_base__RawAverageInt
#define FCD_03521_pot_color_cap1__GetAverageInt FCD_08f41_adc_base__GetAverageInt
#define FCD_03521_pot_color_cap1__GetVoltage FCD_08f41_adc_base__GetVoltage
#define FCD_03521_pot_color_cap1__RawEnable FCD_08f41_adc_base__RawEnable
#define FCD_03521_pot_color_cap1__RawSampleByte FCD_08f41_adc_base__RawSampleByte
#define FCD_03521_pot_color_cap1__GetInt FCD_08f41_adc_base__GetInt
#define FCD_03521_pot_color_cap1__RawDisable FCD_08f41_adc_base__RawDisable
#define FCD_03521_pot_color_cap1__GetByte FCD_08f41_adc_base__GetByte

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 7\CAL\includes.c"


/*=----------------------------------------------------------------------=*\
   Use :Supplementary defines
\*=----------------------------------------------------------------------=*/

/*========================================================================*\
   Use :lutFilteredNoise
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :lut1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_spi
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Send text to the SPI console
       :
       :Parameters for macro Prv_TextConsole:
       :  str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_01531_cal_spi__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :SPI_Master1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sends a string of bytes to the SPI bus
       :
       :Parameters for macro SendString:
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__SendString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{
	//Local variable definitions
	MX_UINT8 FCL_CH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_LEN;


	FCL_LEN = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
	FCL_IDX = 0;

	while (FCL_IDX < FCL_LEN)
	{

		FC_CAL_SPI_Master_Byte_1(FCL_STR[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to read a string of bytes from the SPI bus.
       :
       :Parameters for macro GetString:
       :  NumBytes : MX_UINT8
       :  Ch : MX_UINT8
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES, MX_UINT8 FCL_CH)
{
	//Local variable definitions


	FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

	while (FCL_NUMBYTES)
	{

		FCL_CH = FC_CAL_SPI_Master_Byte_1(0x55);

		FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, &FCL_CH,1, FCR_RETVAL,20);

		FCL_NUMBYTES = FCL_NUMBYTES - 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :General purpose SPI send byte macro
       :
       :Parameters for macro SendChar:
       :  Char : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__SendChar(MX_UINT8 FCL_CHAR)
{

	FC_CAL_SPI_Master_Byte_1(FCL_CHAR);

}

/*=----------------------------------------------------------------------=*\
   Use :General purpose SPI get byte macro
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_06c41_SPI_Master1__GetChar()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_SPI_Master_Byte_1(0x55);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Deactivates the SPI peripheral leaving the I/O pins in a state where they can be used for general purpose I/O.
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__UnInitialise()
{

	FC_CAL_SPI_Master_Uninit_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Activates the SPI peripheral and claims control over the I/O pins.
\*=----------------------------------------------------------------------=*/
void FCD_06c41_SPI_Master1__Initialise()
{

	FC_CAL_SPI_Master_Init_1();

}


/*========================================================================*\
   Use :ctrl_lcd
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()
{




	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Local variable definitions
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;


	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		#else


			FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		#endif

		FCL_IDX = FCL_IDX + 1;


	}


}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Local variable definitions
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Local variable definitions
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 2 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
		{

			FCL_Y = 0x80;

		} else {

			FCL_Y = 0xC0;

		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 2 == 4

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Parameters for macro Command:
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Local variable definitions
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Parameters for macro ScrollDisplay:
       :  Position : Holds the number of positions to shift the display
       :  Direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Local variable definitions
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	if (FCL_DIRECTION == 0)
	{

		FCL_CMD = 0x18;


	} else {

		FCL_CMD = 0x1C;


	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
	//Local variable definitions
	MX_UINT8 FCL_NIBBLE;


	//Comment:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, D, 0x1, 0x0, 0);
		FCP_SET(B, D, 0x2, 0x1, 0);
		FCP_SET(B, D, 0x4, 0x2, 0);
		FCP_SET(B, D, 0x8, 0x3, 0);
		FCP_SET(B, D, 0x100, 0x8, 0);
		FCP_SET(B, D, 0x200, 0x9, 0);

		#if (0)

		//Code has been optimised out by the pre-processor
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
		FCP_SET(B, D, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x8, 0x3, (FCL_NIBBLE & 0x01));

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	//Comment:
	//Output byte to pins

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	//Comment:
	//Output byte to port

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	if (FCL_TYPE)
	{

		FCP_SET(B, D, 0x100, 0x8, 1);

	// } else {

	}

	FCI_DELAYBYTE_US(100);

	//Comment:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, D, 0x200, 0x9, 1);

	FCI_DELAYBYTE_US(100);

	FCP_SET(B, D, 0x200, 0x9, 0);

	FCI_DELAYBYTE_US(100);

	#if (1) // 0 == 0

		FCP_SET(B, D, 0x1, 0x0, 0);
		FCP_SET(B, D, 0x2, 0x1, 0);
		FCP_SET(B, D, 0x4, 0x2, 0);
		FCP_SET(B, D, 0x8, 0x3, 0);
		FCP_SET(B, D, 0x100, 0x8, 0);

		FCL_NIBBLE = (FCL_DATA & 0xf);
		FCP_SET(B, D, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, D, 0x8, 0x3, (FCL_NIBBLE & 0x01));

		if (FCL_TYPE)
		{

			FCP_SET(B, D, 0x100, 0x8, 1);

		// } else {

		}

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, D, 0x200, 0x9, 1);

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, D, 0x200, 0x9, 0);

		FCI_DELAYBYTE_US(100);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a remap character allowing the PrintString function to automatically swap between pre-defined characters. 
       :The characters can be custom (in the range 0-9) or can point to an existing character in the LCD character map.
       :
       :Parameters for macro RemapCharacter:
       :  RemapIdx : Remap Index, Range: 0 to (Remap Characters - 1)
       :  SearchCharacter : Character to look for a replace
       :  ReplacementCharacter : New character value to use in place of the search character.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{




	#if (1) // 0 == 0

		FCP_SET(B, D, 0x1, 0x0, 0);
		FCP_SET(B, D, 0x2, 0x1, 0);
		FCP_SET(B, D, 0x4, 0x2, 0);
		FCP_SET(B, D, 0x8, 0x3, 0);
		FCP_SET(B, D, 0x100, 0x8, 0);
		FCP_SET(B, D, 0x200, 0x9, 0);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}


/*========================================================================*\
   Use :lcd_eb005
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f41_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL, FCRsz_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f41_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.001221);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(9, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(9, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :pot_color_cap1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Timer1_Interrupt()
{

	#if 0 // Disabled code
	// Output
	// Output: 1 -> B0
	FCP_SET(M, B, 0x0001, 0, (1));
	#endif // #if 0: Disabled code
	// Call Macro
	// Call Macro: audioSignal=Read_ADC()
	FCV_AUDIOSIGNAL = FCM_Read_ADC();

	// Calculation
	// Calculation:
	//  signedAudio = audioSignal - 32768
	FCV_SIGNEDAUDIO = FCV_AUDIOSIGNAL - 32768;

	// Circular Buffer
	// C Code:
	FCV_CIRCULARBUFFER[FCV_CIRCULARBUFFERINDEX] = FCV_SIGNEDAUDIO;
	FCV_CIRCULARBUFFERINDEX = (FCV_CIRCULARBUFFERINDEX+1)%(FCV_CIRCULARBUFFERSIZE);

	volatile register int A asm("A");
	volatile register int B asm("B");

	// audio processing
	// C Code:
	FCV_WAHBUFFER[0] = FCV_SIGNEDAUDIO >> 1;

	if (FCV_ISFX0)
	{
	            if (FCV_LUTTARGET != FCV_LUTVAL)
	            {
	                FCV_LUTCURRENT = FCV_LUTTARGET;
	                FCV_LUTTARGET = FCV_LUTVAL;

	                FCV_FRACTREM = FCV_FRACINIT;
	            }

	            CORCONbits.IF = 0; //fractional mode
	            asm("CLR A");
	            asm("MOV.W _FCV_LUTCURRENT, W4");
	            asm("MOV.W _FCV_LUTTARGET, W5");
	            asm("MOV.W _FCV_FRACTREM, W6");

	            asm("LAC W4, A");
	            asm("MSC W4*W6, A");
	            asm("MAC W5*W6, A");

	            FCV_SINEDATA = __builtin_ACCH(A);
	            CORCONbits.IF = 1; //integer mode

	            FCV_FRACTREM = FCV_FRACTREM + FCV_FRACINIT;

	    switch (FCV_FX0COUNTER)
	    {
	        case 0: //tremolo
	            
	            CORCONbits.IF = 0; //fractional mode
	            asm("CLR A");
	            asm("CLR B");

	            asm("MOV.W _FCV_SIGNEDAUDIO, W4");
	            asm("MOV.W _FCV_SINEDATA, W5");
	            asm("MPY W4*W5, B");

	            //do wet dry here
	                                          //w4 = dry
	            asm("SAC B, W5");             //w5 = wet
	            asm("CLR B");
	            asm("CLR A");
	            asm("MOV.W _FCV_WETDRY, W6"); //w6 = mix

	            asm("LAC W4, A"); //dry
	            asm("MSC W4*W6, A"); // dry* -wDmix
	            asm("MAC W5*W6, A"); // +wet*wDmix

	            //output
	            FCV_SIGNEDAUDIO = __builtin_ACCH(A);
	            asm("CLR B");
	            asm("CLR A");

	            CORCONbits.IF = 1; //integer mode
	            break;

	        case 1: //vibrato
	            FCV_VIBRATOLUTVAL = FCV_LUTVAL / FCV_VIBRATODEPTH;

	            if (FCV_VIBRATOLUTTARGET != FCV_VIBRATOLUTVAL)
	            {
	                FCV_LUTCURRENT = FCV_VIBRATOLUTTARGET;
	                FCV_VIBRATOLUTTARGET = FCV_VIBRATOLUTVAL;
	                FCV_FRAC = FCV_FRACINIT;
	            }

	            CORCONbits.IF = 0; //fractional mode
	            asm("CLR A");
	            asm("CLR B");

	            FCV_AUDIOHOLDA = FCV_CIRCULARBUFFER[(FCV_CIRCULARBUFFERINDEX + FCV_LUTCURRENT) % FCV_CIRCULARBUFFERSIZE];
	            FCV_AUDIOHOLDB = FCV_CIRCULARBUFFER[(FCV_CIRCULARBUFFERINDEX + FCV_VIBRATOLUTTARGET) % FCV_CIRCULARBUFFERSIZE];

	            asm("MOV.W _FCV_AUDIOHOLDA, W4");
	            asm("MOV.W _FCV_AUDIOHOLDB, W5");
	            asm("MOV.W _FCV_FRAC, W6");

	            asm("LAC W4, B");
	            asm("MSC W4*W6, B");
	            asm("MAC W5*W6, B");

	            FCV_SIGNEDAUDIO = __builtin_ACCH(B);
	            CORCONbits.IF = 1; //integer mode
	            FCV_FRAC = FCV_FRAC + FCV_FRACINIT;

	        break;
	    }
	}

	else if (FCV_ISFX1)
	{
	    switch (FCV_FX1COUNTER)
	    {
	        case 0: //chorus
	        //interpolate lut value
	        if (FCV_CHORUSLUTVAL != FCV_CHORUSLUTTARGETVAL)
	        {
	            if (FCV_CHORUSLUTVAL < FCV_CHORUSLUTTARGETVAL)
	            {
	                FCV_CHORUSLUTVAL++;
	            }
	            else if (FCV_CHORUSLUTVAL > FCV_CHORUSLUTTARGETVAL)
	            {
	                FCV_CHORUSLUTVAL--;
	            }
	        }
	        else
	        {
	            FCV_CHORUSLUTVAL = FCV_CHORUSLUTTARGETVAL;
	        }

	        //update read heads
	        for(FCV_CHORUSINDEXITERATOR = 0; FCV_CHORUSINDEXITERATOR < 4; FCV_CHORUSINDEXITERATOR++)
	        {
	            FCV_CHORUSINDEX[FCV_CHORUSINDEXITERATOR] = (FCV_CIRCULARBUFFERINDEX + FCV_CHORUSSAMPLEDELAYVOICE[FCV_CHORUSINDEXITERATOR] + FCV_CHORUSLUTVAL )% (FCV_CIRCULARBUFFERSIZE);
	        } 


	        //create summed voices
	        FCV_CHORUSVOICESUMLONG = FCV_CIRCULARBUFFER[FCV_CHORUSINDEX[0]];
	        for (FCV_CHORUSINDEXITERATOR = 1; FCV_CHORUSINDEXITERATOR < FCV_CHORUSNUMVOICES; FCV_CHORUSINDEXITERATOR++)
	        {
	           FCV_CHORUSVOICESUMLONG = FCV_CHORUSVOICESUMLONG + FCV_CIRCULARBUFFER[FCV_CHORUSINDEX[FCV_CHORUSINDEXITERATOR]];
	        }

	        //output TODO: requires variables
	        FCV_CHORUSVOICESUMLONG = FCV_CHORUSVOICESUMLONG / FCV_CHORUSNUMVOICES;
	        FCV_CHORUSVOICESUM = FCV_CHORUSVOICESUMLONG;

	        asm("CLR A");

	        asm("MOV.W _FCV_SIGNEDAUDIO, W4");    //dry
	        asm("MOV.W _FCV_CHORUSVOICESUM, W5"); //wet
	        asm("MOV.W _FCV_WETDRY, W6");         //w6 = mix

	        asm("LAC W4, A"); //dry
	        asm("MSC W4*W6, A"); // dry* -wDmix
	        asm("MAC W5*W6, A"); // +wet*wDmix

	        //output
	        FCV_SIGNEDAUDIO = __builtin_ACCH(A);
	        break;

	        case 1:
	        //flanger
	        FCV_FLANGERLUTVAL = FCV_LUTVAL / FCV_FLANGERDEPTH;

	        if (FCV_FLANGERLUTTARGET != FCV_FLANGERLUTVAL)
	        {
	            FCV_LUTCURRENT = FCV_FLANGERLUTTARGET;
	            FCV_FLANGERLUTTARGET = FCV_FLANGERLUTVAL;

	            FCV_FRAC = FCV_FRACINIT;
	        }
	        CORCONbits.IF = 0; //fractional mode
	        asm("CLR A");
	        asm("CLR B");

	        FCV_AUDIOHOLDA = FCV_CIRCULARBUFFER[(FCV_CIRCULARBUFFERINDEX + FCV_LUTCURRENT) % FCV_CIRCULARBUFFERSIZE];
	        FCV_AUDIOHOLDB = FCV_CIRCULARBUFFER[(FCV_CIRCULARBUFFERINDEX + FCV_FLANGERLUTTARGET) % FCV_CIRCULARBUFFERSIZE];

	        asm("MOV.W _FCV_AUDIOHOLDA, W4");
	        asm("MOV.W _FCV_AUDIOHOLDB, W5");

	        //asm("MOV.W _FCV_LUTCURRENT, W4");
	        //asm("MOV.W _FCV_FLANGERLUTTARGET, W5");
	        asm("MOV.W _FCV_FRAC, W6");

	        asm("LAC W4, A");
	        asm("MSC W4*W6, A");
	        asm("MAC W5*W6, A");

	        FCV_SINEDATA = __builtin_ACCH(A);
	        CORCONbits.IF = 1; //integer mode
	        FCV_FRAC = FCV_FRAC + FCV_FRACINIT;

	        FCV_SIGNEDAUDIO = (FCV_SINEDATA + FCV_SIGNEDAUDIO)/2; //output is 50/50
	        break;
	    }

	}
	//Bypass - no effect
	/*else if (FCV_ISFX2)
	{
	}*/

	else if (FCV_ISFX3)
	{
	    switch (FCV_FX3COUNTER)
	    {
	        case 0: //bitcrusher
	        FCV_BITCRUSHERSAMPLECOUNTER++;
	        if (FCV_BITCRUSHERSAMPLECOUNTER >= FCV_BITCRUSHERADC)
	        {
	            FCV_BITCRUSHERSAMPLECOUNTER = 0;
	            FCV_SIGNEDAUDIO = FCV_CIRCULARBUFFER[(FCV_CIRCULARBUFFERINDEX + 2) % FCV_CIRCULARBUFFERSIZE]; // equal to previous sample in the buffer.
	            //output sample = last sample.
	        }

	        FCV_SIGNEDAUDIO = FCV_SIGNEDAUDIO >> (16-FCV_BITCRUSHERRESOLUTION);
	        FCV_SIGNEDAUDIO = FCV_SIGNEDAUDIO << (16-FCV_BITCRUSHERRESOLUTION);

	        break;

	        case 1: // distortion
	        FCV_DISTORTIONLONG = FCV_SIGNEDAUDIO;
	        FCV_DISTORTIONLONG = FCV_DISTORTIONLONG + FCV_DISTORTIONBIAS;
	        FCV_DISTORTIONLONG = FCV_DISTORTIONLONG * (FCV_DISTORTIONGAIN/100);

	        if (FCV_DISTORTIONLONG > FCV_DISTORTIONRAILS)
	        {
	            FCV_DISTORTIONLONG = FCV_DISTORTIONRAILS;
	        }
	        else if (FCV_DISTORTIONLONG < -FCV_DISTORTIONRAILS)
	        {
	            FCV_DISTORTIONLONG = -FCV_DISTORTIONRAILS;
	        }
	        FCV_SIGNEDAUDIO = FCV_DISTORTIONLONG;
	        break;
	    }
	}

	else if (FCV_ISFX4) //wah
	{

	    asm("CLR A");
	    CORCONbits.IF   = 0; //fractional
	    CORCONbits.SATA = 1; //enable Sat in the first place

	    FCV_WAHHOLDA = FCV_WAHBUFFER[0];
	    FCV_WAHHOLDB = FCV_WAHXFIXED[0];
	    asm("MOV.W _FCV_WAHHOLDA, W4");
	    asm("MOV.W _FCV_WAHHOLDB, W5");
	    asm("MAC W4*W5, A");

	    FCV_WAHHOLDA = FCV_WAHBUFFER[1];
	    FCV_WAHHOLDB = FCV_WAHXFIXED[1];
	    asm("MOV.W _FCV_WAHHOLDA, W4");
	    asm("MOV.W _FCV_WAHHOLDB, W5");
	    asm("MSC W4*W5, A");

	    FCV_WAHHOLDA = FCV_WAHBUFFER[2];
	    FCV_WAHHOLDB = FCV_WAHXFIXED[2];
	    asm("MOV.W _FCV_WAHHOLDA, W4");
	    asm("MOV.W _FCV_WAHHOLDB, W5");
	    asm("MSC W4*W5, A");

	    FCV_WAHHOLDA = FCV_WAHBUFFER[3];
	    FCV_WAHHOLDB = FCV_WAHXFIXED[3];
	    asm("MOV.W _FCV_WAHHOLDA, W4");
	    asm("MOV.W _FCV_WAHHOLDB, W5");
	    asm("MSC W4*W5, A");
	    FCV_WAHOUT = __builtin_ACCH(A);
	    
	    CORCONbits.IF = 1;
	    CORCONbits.SATA = 0;

	    FCV_WAHOUT = FCV_WAHOUT * 2; //<< 2; //scaling from reduced coeffs //formerly *4
	    FCV_CHORUSVOICESUMLONG = FCV_WAHOUT;
	    FCV_CHORUSVOICESUMLONG = FCV_CHORUSVOICESUMLONG + (FCV_SIGNEDAUDIO/2);
	    //FCV_SIGNEDAUDIO = (FCV_SIGNEDAUDIO/4) + (FCV_WAHOUT/2);
	    FCV_SIGNEDAUDIO = FCV_CHORUSVOICESUMLONG;
	}

	//buffer handling
	FCV_WAHBUFFER[3] = FCV_WAHBUFFER[2];
	FCV_WAHBUFFER[2] = FCV_SIGNEDAUDIO;
	FCV_WAHBUFFER[1] = FCV_WAHBUFFER[0];

	// Calculation
	// Calculation:
	//  audioSignal = signedAudio + 32768
	FCV_AUDIOSIGNAL = FCV_SIGNEDAUDIO + 32768;

	// Call Macro
	// Call Macro: Write_DAC(audioSignal)
	FCM_Write_DAC(FCV_AUDIOSIGNAL);

	#if 0 // Disabled code
	// Output
	// Output: 0 -> B0
	FCP_SET(M, B, 0x0001, 0, (0));
	#endif // #if 0: Disabled code
}

/*=----------------------------------------------------------------------=*\
   Use :LFO
\*=----------------------------------------------------------------------=*/
void FCM_Timer2_Interrupt()
{

	#if 0 // Disabled code
	// Output
	// Output: 1 -> B1
	FCP_SET(M, B, 0x0002, 1, (1));
	#endif // #if 0: Disabled code
	// C Code
	// C Code:
	/*
	  Enter C code below this comment
	*/

	FCV_LUT_INDEX = (FCV_LUT_INDEX+FCV_LUTOFFSET)%FCV_SIZEOFLUT;

	// Calculation
	// Calculation:
	//  lutVal = lut1 :: GetInt (LUT_index)
	FCV_LUTVAL = FCD_00fb1_lut1__INTLIST(FCV_LUT_INDEX);

	// 0.25Hz for chorus.
	// Decision: noiseCounter == 3?
	if (FCV_NOISECOUNTER == 3)
	{

		// Calculation
		// Calculation:
		//  noiseCounter = noiseCounter + 0
		FCV_NOISECOUNTER = FCV_NOISECOUNTER + 0;

		// Calculation
		// Calculation:
		//  chorusLutTargetVal = lutFilteredNoise :: GetInt (chorusLUTIndex)
		FCV_CHORUSLUTTARGETVAL = FCD_00fb2_lutFilteredNoise__INTLIST(FCV_CHORUSLUTINDEX);

		// Index Increment
		// C Code:
		FCV_CHORUSLUTINDEX = (FCV_CHORUSLUTINDEX+1)%FCV_SIZEOFLUT;

	} else {

		// Calculation
		// Calculation:
		//  noiseCounter = noiseCounter + 1
		FCV_NOISECOUNTER = FCV_NOISECOUNTER + 1;

	}

	#if 0 // Disabled code
	// Output
	// Output: 0 -> B1
	FCP_SET(M, B, 0x0002, 1, (0));
	#endif // #if 0: Disabled code
}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_timer3_interrupt()
{

	#if 0 // Disabled code
	// Output
	// Output: 1 -> B2
	FCP_SET(M, B, 0x0004, 2, (1));
	#endif // #if 0: Disabled code
	// C Code
	// C Code:
	/*
	  Enter C code below this comment
	*/

	if (FCV_ISFX0)
	{
	//tremolo and vibrato
	    FCV_VOLTAGEADC = FCD_03521_pot_color_cap1__RawSampleInt();
		FCV_VOLTAGEADC = FCV_VOLTAGEADC >> 8;
		FCV_VOLTAGEADC = FCV_VOLTAGEADC + 1;
		if (FCV_VOLTAGEDISPLAY != FCV_VOLTAGEADC)
		{
			FCV_VOLTAGEDISPLAY = FCV_VOLTAGEADC;
			FCD_0ad31_lcd_eb005__ClearLine(1);
	        FCD_0ad31_lcd_eb005__PrintString("Freq.(Hz)", 16);
	        FCD_0ad31_lcd_eb005__Cursor(10, 20);
			FCD_0ad31_lcd_eb005__PrintFormattedNumber(FCV_VOLTAGEDISPLAY, 1);
			FCV_LUTOFFSET = FCV_VOLTAGEADC;
		}
	}

	else if (FCV_ISFX1)
	{
	    if (FCV_FX1COUNTER == 1) //flanger
	    {
			FCV_VOLTAGEADC = FCD_03521_pot_color_cap1__RawSampleInt();
			FCV_VOLTAGEADC = FCV_VOLTAGEADC >> 8;
			FCV_VOLTAGEADC = FCV_VOLTAGEADC + 1;
			if (FCV_VOLTAGEDISPLAY != FCV_VOLTAGEADC)
			{
				FCV_VOLTAGEDISPLAY = FCV_VOLTAGEADC;
				FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Freq.(Hz)", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
		    	FCD_0ad31_lcd_eb005__PrintFormattedNumber(FCV_VOLTAGEDISPLAY, 1);
				FCV_LUTOFFSET = FCV_VOLTAGEADC;
			}
	    }
	}
	//else if (FCV_ISFX2)
	//{
	// do nothing here. bypassed.
	//}
	else if (FCV_ISFX3)
	{
	    if (FCV_FX3COUNTER == 0) //bitCrusher
	    {
			FCV_BITCRUSHERADC = FCD_03521_pot_color_cap1__RawSampleInt();
			FCV_BITCRUSHERADC = FCV_BITCRUSHERADC >> 4;
			FCV_BITCRUSHERADC = FCV_BITCRUSHERADC + 2;
			if (FCV_VOLTAGEDISPLAY != FCV_BITCRUSHERADC)
			{
				FCV_VOLTAGEDISPLAY = FCV_BITCRUSHERADC;
				FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Skip at:", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
				FCD_0ad31_lcd_eb005__PrintFormattedNumber(FCV_VOLTAGEDISPLAY, 1);
			}
	    }

	}
	else if (FCV_ISFX4)
	{
		FCV_WAHADC = FCD_03521_pot_color_cap1__RawSampleInt();
		FCV_WAHADC = FCV_WAHADC >> 1;
		FCV_WAHADC = FCV_WAHADC << 1; //reduce resolution
		FCV_WAHADC = FCV_WAHADC + 300; // set low bound

		if (FCV_VOLTAGEDISPLAY != FCV_WAHADC)
		{
			FCV_VOLTAGEDISPLAY = FCV_WAHADC;
			FCD_0ad31_lcd_eb005__ClearLine(1);
	        FCD_0ad31_lcd_eb005__PrintString("Freq.(Hz)", 16);
	        FCD_0ad31_lcd_eb005__Cursor(10, 20);
			FCD_0ad31_lcd_eb005__PrintNumber(FCV_VOLTAGEDISPLAY);
	        
	        FCV_WAHFC = flt_mul(2, sin(flt_div(flt_mul(3.1416, flt_fromi(FCV_WAHADC)), 24000)));
	        FCV_WAHQ = flt_div(1.0, flt_fromi(FCV_WAHQDAMPERINT));
	        FCV_WAHLITTLEQ = flt_sub(1, (flt_mul(FCV_WAHFC, FCV_WAHQ)));
	        FCV_WAHNORM = float32_sqrt(FCV_WAHQ);
	        FCV_WAHB_FLOAT[0] = flt_mul(FCV_WAHFC, FCV_WAHNORM);
	        FCV_WAHB_FLOAT[1] = FCV_WAHB_FLOAT[0];
	        FCV_WAHA_FLOAT[0] = flt_sub(flt_sub((flt_mul(FCV_WAHFC, FCV_WAHFC)), FCV_WAHLITTLEQ), 1);
	        FCV_WAHA_FLOAT[1] = FCV_WAHLITTLEQ;
	        FCV_WAHXFIXED[0] = flt_toi(flt_mul(FCV_WAHB_FLOAT[0], 8192));
	        FCV_WAHXFIXED[1] = FCV_WAHXFIXED[0];
	        FCV_WAHXFIXED[2] = flt_toi(flt_mul(FCV_WAHA_FLOAT[0], 8192));
	        FCV_WAHXFIXED[3] = flt_toi(flt_mul(FCV_WAHA_FLOAT[1], 8192));
	    }
	}

	#if 0 // Disabled code
	// Output
	// Output: 0 -> B2
	FCP_SET(M, B, 0x0004, 2, (0));
	#endif // #if 0: Disabled code
}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_ButtonInterrupt()
{

	#if 0 // Disabled code
	// Output
	// Output: 1 -> B0
	FCP_SET(M, B, 0x0001, 0, (1));
	#endif // #if 0: Disabled code
	// Call Macro
	// Call Macro: buttonReadIn()
	FCM_buttonReadIn();

	// bank selection
	// C Code:
	// effect bank and selection
	if (FCV_ISB0DOWN && !FCV_FXBANKSWITCHSTATE)
	{
	    FCV_FXBANKSWITCHSTATE = 1;
	    FCV_PARAMCOUNTER  = 0;

	    if (!FCV_ISFX0)
	    {
	        FCV_ISFX0 = 1;

	        FCV_ISFX1 = 0;
	        FCV_ISFX2 = 0;
	        FCV_ISFX3 = 0;
	        FCV_ISFX4 = 0;
	    }
	    else
	    {
	         FCV_FX0COUNTER = (FCV_FX0COUNTER + 1) % 2;
	    }


	    FCD_0ad31_lcd_eb005__ClearLine(1);
	    switch (FCV_FX0COUNTER)
	    {
	        case 0:
	            FCD_0ad31_lcd_eb005__ClearLine(0);
	            FCD_0ad31_lcd_eb005__PrintString("Tremolo", 16);
	            FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
	            FCD_0ad31_lcd_eb005__PrintNumber(FCV_WETDRYDISPLAY);
	            FCV_PARAMNUMBER = 1;
	        break;

	        case 1:
	            FCD_0ad31_lcd_eb005__ClearLine(0);
	            FCD_0ad31_lcd_eb005__PrintString("Vibrato", 16);
	            FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
	            FCD_0ad31_lcd_eb005__PrintNumber(FCV_VIBRATODEPTHDISPLAY);
	            FCV_PARAMNUMBER = 1;
	        break;
	    }
	}

	else if (FCV_ISB1DOWN && !FCV_FXBANKSWITCHSTATE)
	{
	    FCV_FXBANKSWITCHSTATE = 1;
	    FCV_PARAMCOUNTER  = 0;

	    if(!FCV_ISFX1)
	    {
	        FCV_ISFX1 = 1;

	        FCV_ISFX0 = 0;
	        FCV_ISFX2 = 0;
	        FCV_ISFX3 = 0;
	        FCV_ISFX4 = 0;
	    }
	    else
	    {
	         FCV_FX1COUNTER = (FCV_FX1COUNTER + 1) % 2;
	    }



	    switch (FCV_FX1COUNTER)
	    {
	        case 0:
	            FCD_0ad31_lcd_eb005__ClearLine(0);
	            FCD_0ad31_lcd_eb005__PrintString("Chorus", 16);
	            FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Voices:", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
	            FCD_0ad31_lcd_eb005__PrintNumber(FCV_CHORUSNUMVOICES);

	            FCV_PARAMNUMBER = 2;
	        break;

	        case 1:
	            FCD_0ad31_lcd_eb005__ClearLine(0);
	            FCD_0ad31_lcd_eb005__PrintString("Flanger", 16);
	            FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
	            FCD_0ad31_lcd_eb005__PrintNumber(FCV_WETDRYDISPLAY);
	            FCV_PARAMNUMBER = 1;
	        break;
	    }
	}

	else if (FCV_ISB2DOWN && !FCV_FXBANKSWITCHSTATE && !FCV_ISFX2)
	{
	    FCV_FXBANKSWITCHSTATE = 1;
	    FCV_PARAMCOUNTER  = 0;

	    if(!FCV_ISFX2)
	    {
	        FCV_ISFX2 = 1;

	        FCV_ISFX0 = 0;
	        FCV_ISFX1 = 0;
	        FCV_ISFX3 = 0;
	        FCV_ISFX4 = 0;
	    }
	    FCD_0ad31_lcd_eb005__ClearLine(0);
	    FCD_0ad31_lcd_eb005__PrintString("Bypass", 16);
	    FCD_0ad31_lcd_eb005__ClearLine(1);
	    FCV_PARAMNUMBER = 1;
	}

	else if (FCV_ISB3DOWN && !FCV_FXBANKSWITCHSTATE)
	{
	    FCV_FXBANKSWITCHSTATE = 1;
	    FCV_PARAMCOUNTER  = 0;

	    if(!FCV_ISFX3)
	    {
	        FCV_ISFX3 = 1;

	        FCV_ISFX0 = 0;
	        FCV_ISFX1 = 0;
	        FCV_ISFX2 = 0;
	        FCV_ISFX4 = 0;
	    }
	    else
	    {
	         FCV_FX3COUNTER = (FCV_FX3COUNTER + 1) % 2;
	    }

	    switch (FCV_FX3COUNTER)
	    {
	        case 0:
	            FCD_0ad31_lcd_eb005__ClearLine(0);
	            FCD_0ad31_lcd_eb005__PrintString("Bit Crusher", 16);
	            FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Resl.", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
	            FCD_0ad31_lcd_eb005__PrintNumber(FCV_BITCRUSHERRESOLUTION);
	            FCV_PARAMNUMBER = 1;
	        break;

	        case 1:
	            FCD_0ad31_lcd_eb005__ClearLine(0);
	            FCD_0ad31_lcd_eb005__PrintString("Distortion", 16);
	            FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Gain", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
	            FCD_0ad31_lcd_eb005__PrintNumber(FCV_DISTORTIONGAINDISPLAY);
	            FCV_PARAMNUMBER = 3;
	        break;
	    }
	}
	else if (FCV_ISB4DOWN && !FCV_FXBANKSWITCHSTATE && !FCV_ISFX4)
	{
	    FCV_FXBANKSWITCHSTATE = 1;
	    FCV_PARAMCOUNTER  = 0;
	    
	    if(!FCV_ISFX4)
	    {
	        FCV_ISFX4 = 1;

	        FCV_ISFX0 = 0;
	        FCV_ISFX1 = 0;
	        FCV_ISFX2 = 0;
	        FCV_ISFX3 = 0;
	    }

	    FCD_0ad31_lcd_eb005__ClearLine(0);
	    FCD_0ad31_lcd_eb005__PrintString("Wah Wah", 16);
	    FCD_0ad31_lcd_eb005__ClearLine(1);
	    FCD_0ad31_lcd_eb005__PrintString("Q", 16);
	    FCD_0ad31_lcd_eb005__Cursor(10, 20);
	    FCD_0ad31_lcd_eb005__PrintNumber(FCV_WAHQDAMPERINT);
	    FCV_PARAMNUMBER = 2;
	}

	// C Code
	// C Code:
	//parameter change
	if(FCV_ISB5DOWN && !FCV_B5SWITCHSTATE)
	{
	    FCV_B5SWITCHSTATE = 1;
	    FCV_PARAMCOUNTER = (FCV_PARAMCOUNTER + 1) % FCV_PARAMNUMBER;

	    if (FCV_ISFX0)
	    {
	        if (FCV_FX0COUNTER == 1) //vibrato
	        {
	            FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
	            FCD_0ad31_lcd_eb005__PrintNumber(FCV_VIBRATODEPTHDISPLAY);
	        }
	        else //for when trem
	        {
	            FCD_0ad31_lcd_eb005__ClearLine(1);
	            FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	            FCD_0ad31_lcd_eb005__Cursor(10, 20);
	            FCD_0ad31_lcd_eb005__PrintNumber(FCV_WETDRYDISPLAY);
	        }
	    }
	    else if (FCV_ISFX1)
	    {
	        switch (FCV_FX1COUNTER)
	        {
	            case 0:
	            //chorus
	                switch (FCV_PARAMCOUNTER)
	                {
	                    case 0: //number voices
	                        FCD_0ad31_lcd_eb005__ClearLine(1);
	                        FCD_0ad31_lcd_eb005__PrintString("Voices:", 16);
	                        FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                        FCD_0ad31_lcd_eb005__PrintNumber(FCV_CHORUSNUMVOICES);
	                    break;

	                    case 1: //wet dry
	                        FCD_0ad31_lcd_eb005__ClearLine(1);
	                        FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	                        FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                        FCD_0ad31_lcd_eb005__PrintNumber(FCV_WETDRYDISPLAY);
	                    break;
	                }
	            break;
	            case 1: //flanger
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_FLANGERDEPTHDISPLAY);
	            break;
	        }
	    }
	    //skip FX2 (this is bypass)
	    else if (FCV_ISFX3)
	    {
	        if (FCV_FX3COUNTER == 1) // only change params on bitcrusher
	        {
	            switch (FCV_PARAMCOUNTER)
	            {
	                case 0: //number voices
	                    FCD_0ad31_lcd_eb005__ClearLine(1);
	                    FCD_0ad31_lcd_eb005__PrintString("Gain", 16);
	                    FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                    FCD_0ad31_lcd_eb005__PrintNumber(FCV_DISTORTIONGAINDISPLAY);
	                break;

	                case 1: //wet dry
	                    FCD_0ad31_lcd_eb005__ClearLine(1);
	                    FCD_0ad31_lcd_eb005__PrintString("Bias %", 16);
	                    FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                    FCD_0ad31_lcd_eb005__PrintNumber(FCV_DISTORTIONBIASDISPLAY);
	                break;
	           
	                case 2: //wet dry
	                    FCD_0ad31_lcd_eb005__ClearLine(1);
	                    FCD_0ad31_lcd_eb005__PrintString("Power %", 16);
	                    FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                    FCD_0ad31_lcd_eb005__PrintNumber(FCV_DISTORTIONRAILSDISPLAY);
	                break;
	            }
	        }
	        else //for when bitcrusher
	        {
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Resl.", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_BITCRUSHERRESOLUTION);
	        }
	    }
	    else if (FCV_ISFX4)
	    {
	        FCD_0ad31_lcd_eb005__ClearLine(1);
	        FCD_0ad31_lcd_eb005__PrintString("Q", 16);
	        FCD_0ad31_lcd_eb005__Cursor(10, 20);
	        FCD_0ad31_lcd_eb005__PrintNumber(FCV_WAHQDAMPERINT);
	    }
	}    

	// C Code
	// C Code:
	// increment and decrement
	if (FCV_ISB6DOWN && !FCV_UPDOWNSWITCHSTATE) //INCREMENT
	{
	    FCV_UPDOWNSWITCHSTATE = 1;
	    if (FCV_ISFX0)
	    {
	        switch (FCV_FX0COUNTER)
	        {
	            case 0:
	                //tremolo
	                //wet dry
	                if (FCV_WETDRY < 32760)
	                {
	                    FCV_WETDRY = FCV_WETDRY + 1638;
	                    FCV_WETDRYDISPLAY = FCV_WETDRYDISPLAY + 5;
	                }
	            break;
	            case 1: //vibrato
	                if (FCV_VIBRATODEPTH > 100)
	                    {
	                        FCV_VIBRATODEPTH = FCV_VIBRATODEPTH - 500;
	                        FCV_VIBRATODEPTHDISPLAY = FCV_VIBRATODEPTHDISPLAY + 5;
	                    }
	            break;
	        }
	    }
	    else if (FCV_ISFX1)
	    {
	        switch (FCV_FX1COUNTER)
	        {
	            case 0:
	                //chorus
	                switch (FCV_PARAMCOUNTER)
	                {
	                    case 0: //number voices
	                        if (FCV_CHORUSNUMVOICES < 4)
	                        {
	                            FCV_CHORUSNUMVOICES++;
	                        }
	                    break;
	                    case 1: //wet dry
	                        if (FCV_WETDRY < 32760)
	                        {
	                            FCV_WETDRY = FCV_WETDRY + 1638;
	                            FCV_WETDRYDISPLAY = FCV_WETDRYDISPLAY + 5;
	                        }
	                    break;
	                }
	            break;
	            case 1:
	                //flanger
	                if (FCV_FLANGERDEPTH > 100)
	                    {
	                        FCV_FLANGERDEPTH = FCV_FLANGERDEPTH - 500;
	                        FCV_FLANGERDEPTHDISPLAY = FCV_FLANGERDEPTHDISPLAY + 5;
	                    }
	            break;
	        }
	    }
	    //else if (FCV_ISFX2)
	    //{
	    //do nothing. bypass
	    //}
	    else if (FCV_ISFX3)
	    {
	        switch (FCV_FX3COUNTER)
	        {
	            case 0: //bitcrusher
	            if (FCV_BITCRUSHERRESOLUTION < 16)
	            {
	                FCV_BITCRUSHERRESOLUTION++;
	            }
	            break;
	            case 1: //distortion
	                switch (FCV_PARAMCOUNTER)
	                {
	                    case 0: //gain
	                        if(FCV_DISTORTIONGAIN < 65000)
	                        {
	                             FCV_DISTORTIONGAIN = FCV_DISTORTIONGAIN + 200;
	                             FCV_DISTORTIONGAINDISPLAY = FCV_DISTORTIONGAIN;
	                             FCV_DISTORTIONGAINDISPLAY = FCV_DISTORTIONGAINDISPLAY/100;
	                        }
	                    break;
	                    case 1: //bias
	                        if(FCV_DISTORTIONBIAS < 32760)
	                        {
	                            FCV_DISTORTIONBIAS = FCV_DISTORTIONBIAS + 1638;
	                            FCV_DISTORTIONBIASDISPLAY = FCV_DISTORTIONBIASDISPLAY + 5;
	                        }
	                    break;
	                    case 2: //rails
	                        if(FCV_DISTORTIONRAILS < 32760)
	                        {
	                            FCV_DISTORTIONRAILS = FCV_DISTORTIONRAILS + 1638;
	                            FCV_DISTORTIONRAILSDISPLAY = FCV_DISTORTIONRAILSDISPLAY + 5;
	                        }
	                    break;
	                }
	            break;
	        }
	    }
	    else if (FCV_ISFX4)
	    {
	        if (FCV_WAHQDAMPERINT < 60)
	        {
	            FCV_WAHQDAMPERINT++;

	            // recalculate coeffs
	            FCV_WAHFC = flt_mul(2, sin(flt_div(flt_mul(3.1416, flt_fromi(FCV_WAHADC)), 24000)));
	            FCV_WAHQ = flt_div(1.0, flt_fromi(FCV_WAHQDAMPERINT));
	            FCV_WAHLITTLEQ = flt_sub(1, (flt_mul(FCV_WAHFC, FCV_WAHQ)));
	            FCV_WAHNORM = float32_sqrt(FCV_WAHQ);
	            FCV_WAHB_FLOAT[0] = flt_mul(FCV_WAHFC, FCV_WAHNORM);
	            FCV_WAHB_FLOAT[1] = FCV_WAHB_FLOAT[0];
	            FCV_WAHA_FLOAT[0] = flt_sub(flt_sub((flt_mul(FCV_WAHFC, FCV_WAHFC)), FCV_WAHLITTLEQ), 1);
	            FCV_WAHA_FLOAT[1] = FCV_WAHLITTLEQ;
	            FCV_WAHXFIXED[0] = flt_toi(flt_mul(FCV_WAHB_FLOAT[0], 8192));
	            FCV_WAHXFIXED[1] = FCV_WAHXFIXED[0];
	            FCV_WAHXFIXED[2] = flt_toi(flt_mul(FCV_WAHA_FLOAT[0], 8192));
	            FCV_WAHXFIXED[3] = flt_toi(flt_mul(FCV_WAHA_FLOAT[1], 8192));
	        }
	    }
	}
	//DECREMENT
	else if (FCV_ISB7DOWN && !FCV_UPDOWNSWITCHSTATE)
	{
	    FCV_UPDOWNSWITCHSTATE = 1;
	    if (FCV_ISFX0)
	    {
	        switch (FCV_FX0COUNTER)
	        {
	            case 0:
	                //tremolo
	                //wet dry
	                if (FCV_WETDRY > 0)
	                {
	                    FCV_WETDRY = FCV_WETDRY - 1638;
	                    FCV_WETDRYDISPLAY = FCV_WETDRYDISPLAY - 5;
	                }
	            break;
	            case 1: //vibrato
	                if (FCV_VIBRATODEPTH < 10100)
	                    {
	                        FCV_VIBRATODEPTH = FCV_VIBRATODEPTH + 500;
	                        FCV_VIBRATODEPTHDISPLAY = FCV_VIBRATODEPTHDISPLAY - 5;
	                    }
	            break;
	        }
	    }
	    else if (FCV_ISFX1)
	    {
	        switch (FCV_FX1COUNTER)
	        {
	            case 0:
	                //chorus
	                switch (FCV_PARAMCOUNTER)
	                {
	                    case 0: //number voices
	                        if (FCV_CHORUSNUMVOICES > 1)
	                        {
	                            FCV_CHORUSNUMVOICES--;
	                        }
	                    break;
	                    case 1: //wet dry
	                        if (FCV_WETDRY > 0)
	                        {
	                            FCV_WETDRY = FCV_WETDRY - 1638;
	                            FCV_WETDRYDISPLAY = FCV_WETDRYDISPLAY - 5;
	                        }
	                    break;
	                }
	            break;
	            case 1:
	                //flanger
	                if (FCV_FLANGERDEPTH < 10100)
	                    {
	                        FCV_FLANGERDEPTH = FCV_FLANGERDEPTH + 500;
	                        FCV_FLANGERDEPTHDISPLAY = FCV_FLANGERDEPTHDISPLAY - 5;
	                    }
	            break;
	        }
	    }
	    else if (FCV_ISFX2)
	    {
	    }
	    //else if (FCV_ISFX3)
	    //{
	    //Do nothing, bypass.
	    //}
	    else if (FCV_ISFX3)
	    {
	        switch (FCV_FX3COUNTER)
	        {
	            case 0: //bitcrusher
	            if (FCV_BITCRUSHERRESOLUTION > 1)
	            {
	                FCV_BITCRUSHERRESOLUTION--;
	            }
	            break;
	            case 1: //distortion
	                switch (FCV_PARAMCOUNTER)
	                {
	                    case 0: //gain
	                        if(FCV_DISTORTIONGAIN >= 200)
	                        {
	                             FCV_DISTORTIONGAIN = FCV_DISTORTIONGAIN - 200;
	                             FCV_DISTORTIONGAINDISPLAY = FCV_DISTORTIONGAIN;
	                             FCV_DISTORTIONGAINDISPLAY = FCV_DISTORTIONGAINDISPLAY/100;
	                        }
	                    break;
	                    
	                    case 1: //bias
	                        if(FCV_DISTORTIONBIAS > -32760)
	                        {
	                            FCV_DISTORTIONBIAS = FCV_DISTORTIONBIAS - 1638;
	                            FCV_DISTORTIONBIASDISPLAY = FCV_DISTORTIONBIASDISPLAY - 5;
	                        }
	                    break;
	                    
	                    case 2: //rails
	                        if(FCV_DISTORTIONRAILS > 1638)
	                        {
	                            FCV_DISTORTIONRAILS = FCV_DISTORTIONRAILS - 1638;
	                            FCV_DISTORTIONRAILSDISPLAY = FCV_DISTORTIONRAILSDISPLAY - 5;
	                        }
	                    break;
	                }
	            break;
	        }
	    }
	    else if (FCV_ISFX4)
	    {
	        if (FCV_WAHQDAMPERINT > 1)
	        {
	            FCV_WAHQDAMPERINT--;

	            // recalculate coeffs
	            FCV_WAHFC = flt_mul(2, sin(flt_div(flt_mul(3.1416, flt_fromi(FCV_WAHADC)), 24000)));
	            FCV_WAHQ = flt_div(1.0, flt_fromi(FCV_WAHQDAMPERINT));
	            FCV_WAHLITTLEQ = flt_sub(1, (flt_mul(FCV_WAHFC, FCV_WAHQ)));
	            FCV_WAHNORM = float32_sqrt(FCV_WAHQ);
	            FCV_WAHB_FLOAT[0] = flt_mul(FCV_WAHFC, FCV_WAHNORM);
	            FCV_WAHB_FLOAT[1] = FCV_WAHB_FLOAT[0];
	            FCV_WAHA_FLOAT[0] = flt_sub(flt_sub((flt_mul(FCV_WAHFC, FCV_WAHFC)), FCV_WAHLITTLEQ), 1);
	            FCV_WAHA_FLOAT[1] = FCV_WAHLITTLEQ;
	            FCV_WAHXFIXED[0] = flt_toi(flt_mul(FCV_WAHB_FLOAT[0], 8192));
	            FCV_WAHXFIXED[1] = FCV_WAHXFIXED[0];
	            FCV_WAHXFIXED[2] = flt_toi(flt_mul(FCV_WAHA_FLOAT[0], 8192));
	            FCV_WAHXFIXED[3] = flt_toi(flt_mul(FCV_WAHA_FLOAT[1], 8192));
	        }
	    }
	}




	//dispay update
	if ((FCV_ISB6DOWN || FCV_ISB7DOWN) && FCV_UPDOWNSWITCHSTATE)
	{
	    FCD_0ad31_lcd_eb005__Cursor(0, 20);
	    FCD_0ad31_lcd_eb005__ClearLine(1);
	    FCD_0ad31_lcd_eb005__PrintFormattedNumber(FCV_PARAMCOUNTER, 1);

	    if (FCV_ISFX0)
	    {
	        switch (FCV_FX0COUNTER)
	        {
	            case 0:
	                //tremolo
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_WETDRYDISPLAY);
	            break;

	            case 1:
	            //vibrato
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_VIBRATODEPTHDISPLAY);
	            break;
	        }
	    }
	    else if (FCV_ISFX1)
	    {

	        switch (FCV_FX1COUNTER)
	        {
	            case 0:
	                switch (FCV_PARAMCOUNTER)
	                {
	                    case 0: //number voices
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Voices:", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_CHORUSNUMVOICES);
	                    break;

	                    case 1: //wet dry
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_WETDRYDISPLAY);
	                    break;
	                }
	            break;
	            case 1:
	            //flanger
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Depth (%)", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_FLANGERDEPTHDISPLAY);
	            break;
	        }
	    }
	    //skip FX2 (this is bypass)
	    else if (FCV_ISFX3)
	    {
	        switch (FCV_FX3COUNTER)
	        {
	            case 0:
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Resl.", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_BITCRUSHERRESOLUTION);
	            break;
	            case 1: //distortion
	                switch (FCV_PARAMCOUNTER)
	                {
	                    case 0: //number voices
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Gain", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_DISTORTIONGAINDISPLAY);
	                    break;

	                    case 1: //bias
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Bias %", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_DISTORTIONBIASDISPLAY);
	                    break;

	                    case 2: //rails
	                FCD_0ad31_lcd_eb005__ClearLine(1);
	                FCD_0ad31_lcd_eb005__PrintString("Power %", 16);
	                FCD_0ad31_lcd_eb005__Cursor(10, 20);
	                FCD_0ad31_lcd_eb005__PrintNumber(FCV_DISTORTIONRAILSDISPLAY);
	                    break;
	                }
	            break;
	        }
	    }
	    else if (FCV_ISFX4)
	    {
	        FCD_0ad31_lcd_eb005__ClearLine(1);
	        FCD_0ad31_lcd_eb005__PrintString("Q", 16);
	        FCD_0ad31_lcd_eb005__Cursor(10, 20);
	        FCD_0ad31_lcd_eb005__PrintNumber(FCV_WAHQDAMPERINT);
	    }
	}    

	// C Code
	// C Code:
	//button state reset

	if (!FCV_ISB0DOWN && !FCV_ISB1DOWN && !FCV_ISB2DOWN && !FCV_ISB3DOWN && !FCV_ISB4DOWN && FCV_FXBANKSWITCHSTATE)
	{
	    FCV_FXBANKSWITCHSTATE = 0;
	}

	if (!FCV_ISB5DOWN && FCV_B5SWITCHSTATE)
	{
	    FCV_B5SWITCHSTATE = 0;
	}

	if (!FCV_ISB6DOWN && !FCV_ISB7DOWN && FCV_UPDOWNSWITCHSTATE)
	{
	    FCV_UPDOWNSWITCHSTATE = 0;
	}

	#if 0 // Disabled code
	// Output
	// Output: 0 -> B0
	FCP_SET(M, B, 0x0001, 0, (0));
	#endif // #if 0: Disabled code
}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_buttonReadIn()
{

	// Input
	// Input: B0 -> isB0Down
	FCV_ISB0DOWN = FCP_GET(B, B, 0x0001, 0);
	// Input
	// Input: B1 -> isB1Down
	FCV_ISB1DOWN = FCP_GET(B, B, 0x0002, 1);
	// Input
	// Input: B2 -> isB2Down
	FCV_ISB2DOWN = FCP_GET(B, B, 0x0004, 2);
	// Input
	// Input: B3 -> isB3Down
	FCV_ISB3DOWN = FCP_GET(B, B, 0x0008, 3);
	// Input
	// Input: B4 -> isB4Down
	FCV_ISB4DOWN = FCP_GET(B, B, 0x0010, 4);
	// Input
	// Input: B5 -> isB5Down
	FCV_ISB5DOWN = FCP_GET(B, B, 0x0020, 5);
	// Input
	// Input: B6 -> isB6Down
	FCV_ISB6DOWN = FCP_GET(B, B, 0x0040, 6);
	// Input
	// Input: B7 -> isB7Down
	FCV_ISB7DOWN = FCP_GET(B, B, 0x0080, 7);
}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCM_Read_ADC()
{
	//Local variable definitions
	MX_UINT8 FCL_LOWER;
	MX_UINT8 FCL_MID;
	MX_UINT8 FCL_UPPER;
	MX_UINT16 FCR_RETVAL;


	// Output
	// Output: 0 -> F0
	FCP_SET(M, F, 0x0001, 0, (0));
	// Call Component Macro
	// Call Component Macro: .upper=SPI_Master1::GetChar()
	FCL_UPPER = FCD_06c41_SPI_Master1__GetChar();

	// Call Component Macro
	// Call Component Macro: .mid=SPI_Master1::GetChar()
	FCL_MID = FCD_06c41_SPI_Master1__GetChar();

	// Call Component Macro
	// Call Component Macro: .lower=SPI_Master1::GetChar()
	FCL_LOWER = FCD_06c41_SPI_Master1__GetChar();

	// Output
	// Output: 1 -> F0
	FCP_SET(M, F, 0x0001, 0, (1));
	// Calculation
	// Calculation:
	//  .Return = .upper << 12
	//  .Return = .Return | (.mid << 4)
	//  .Return = .Return | (.lower >> 4)
	FCR_RETVAL = FCL_UPPER << 12;
	FCR_RETVAL = FCR_RETVAL | (FCL_MID << 4);
	FCR_RETVAL = FCR_RETVAL | (FCL_LOWER >> 4);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Write_DAC:
       :  value : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCM_Write_DAC(MX_UINT16 FCL_VALUE)
{
	//Local variable definitions
	MX_UINT8 FCL_UPPER;
	MX_UINT8 FCL_LOWER;


	// Calculation
	// Calculation:
	//  .upper = .value >> 8
	//  .lower = .value
	FCL_UPPER = FCL_VALUE >> 8;
	FCL_LOWER = FCL_VALUE;

	// Output
	// Output: 0 -> F1
	FCP_SET(M, F, 0x0002, 1, (0));
	// Call Component Macro
	// Call Component Macro: SPI_Master1::SendChar(0x00)
	FCD_06c41_SPI_Master1__SendChar(0x00);

	// Call Component Macro
	// Call Component Macro: SPI_Master1::SendChar(.upper)
	FCD_06c41_SPI_Master1__SendChar(FCL_UPPER);

	// Call Component Macro
	// Call Component Macro: SPI_Master1::SendChar(.lower)
	FCD_06c41_SPI_Master1__SendChar(FCL_LOWER);

	// Output
	// Output: 1 -> F1
	FCP_SET(M, F, 0x0002, 1, (1));
}

/*=----------------------------------------------------------------------=*\
   Use :Supplementary implementations
\*=----------------------------------------------------------------------=*/




/*========================================================================*\
   Use :Main
\*========================================================================*/
int main()
{
ADPCFG = 0xffff;


	// Call Component Macro
	// Call Component Macro: pot_color_cap1::RawEnable()
	FCD_03521_pot_color_cap1__RawEnable();

	// Call Component Macro
	// Call Component Macro: SPI_Master1::Initialise()
	FCD_06c41_SPI_Master1__Initialise();

	// Call Component Macro
	// Call Component Macro: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();

	// Call Component Macro
	// Call Component Macro: lcd_eb005::Cursor(0, 0)
	FCD_0ad31_lcd_eb005__Cursor(0, 0);

	// Call Component Macro
	// Call Component Macro: lcd_eb005::PrintString("BerwickFX")
	FCD_0ad31_lcd_eb005__PrintString("BerwickFX", 10);

	// Call Component Macro
	// Call Component Macro: lcd_eb005::Cursor(0, 20)
	FCD_0ad31_lcd_eb005__Cursor(0, 20);

	// Call Component Macro
	// Call Component Macro: lcd_eb005::PrintString("Bypassed")
	FCD_0ad31_lcd_eb005__PrintString("Bypassed", 9);

	// initialise
	// C Code:
	/*
	  Enter C code below this comment
	*/
	//initialise arrays

	//MUST BE LESS THAN MAXNUMSAMPLES
	FCV_CHORUSSAMPLEDELAYVOICE[0] = 297;
	FCV_CHORUSSAMPLEDELAYVOICE[1] = 478;
	FCV_CHORUSSAMPLEDELAYVOICE[2] = 325;
	FCV_CHORUSSAMPLEDELAYVOICE[3] = 503;

	// C Code
	// C Code:
	/*
	  Enter C code below this comment
	*/
	INTCON1bits.NSTDIS = 1;

	/* Make highest Priority */
	IPC0bits.T1IP0 = 1;
	IPC0bits.T1IP1 = 1;
	IPC0bits.T1IP2 = 1;

	/* Make Lowest Priority */
	IPC1bits.T2IP0 = 1;
	IPC1bits.T2IP1 = 1;
	IPC1bits.T2IP2 = 0;

	IPC1bits.T3IP0 = 1;
	IPC1bits.T3IP1 = 0;
	IPC1bits.T3IP2 = 1;

	IPC5bits.T4IP0 = 0;
	IPC5bits.T4IP1 = 0;
	IPC5bits.T4IP2 = 1;

	/*Enable Nesting */
	INTCON1bits.NSTDIS = 0;


	// Calculation
	// Calculation:
	//  wahFc = 2 * sin (3.1416 * wahADC / 24000)
	//  wahQ = 1.0 / wahQDamperInt
	//  wahLittleQ = 1 - (wahFc * wahQ)
	//  wahNorm = sqrt (wahQ)
	//  wahB_float[0] = wahFc * wahNorm
	//  wahB_float[1] = wahB_float[0]
	//  wahA_float[0] = (wahFc * wahFc) - wahLittleQ - 1
	//  wahA_float[1] = wahLittleQ
	//  wahXFixed[0] = float2int (wahB_float[0] * 8192)
	//  wahXFixed[1] = wahXFixed[0]
	//  wahXFixed[2] = float2int (wahA_float[0] * 8192)
	//  wahXFixed[3] = float2int (wahA_float[1] * 8192)
	FCV_WAHFC = flt_mul(2, sin(flt_div(flt_mul(3.1416, flt_fromi(FCV_WAHADC)), 24000)));
	FCV_WAHQ = flt_div(1.0, flt_fromi(FCV_WAHQDAMPERINT));
	FCV_WAHLITTLEQ = flt_sub(1, (flt_mul(FCV_WAHFC, FCV_WAHQ)));
	FCV_WAHNORM = float32_sqrt(FCV_WAHQ);
	FCV_WAHB_FLOAT[0] = flt_mul(FCV_WAHFC, FCV_WAHNORM);
	FCV_WAHB_FLOAT[1] = FCV_WAHB_FLOAT[0];
	FCV_WAHA_FLOAT[0] = flt_sub(flt_sub((flt_mul(FCV_WAHFC, FCV_WAHFC)), FCV_WAHLITTLEQ), 1);
	FCV_WAHA_FLOAT[1] = FCV_WAHLITTLEQ;
	FCV_WAHXFIXED[0] = flt_toi(flt_mul(FCV_WAHB_FLOAT[0], 8192));
	FCV_WAHXFIXED[1] = FCV_WAHXFIXED[0];
	FCV_WAHXFIXED[2] = flt_toi(flt_mul(FCV_WAHA_FLOAT[0], 8192));
	FCV_WAHXFIXED[3] = flt_toi(flt_mul(FCV_WAHA_FLOAT[1], 8192));

	// Interrupt
	// Interrupt: Enable TMR1
	T1CON = ((T1CON & 0xfffd) | 0x8000);
	T1CON &= 0xff0f;
	PR1=1228-1;
	IEC0bits.T1IE = 1;

	// Interrupt
	// Interrupt: Enable TMR2
	T2CON = ((T2CON & 0xfffd) | 0x8000);
	T2CON = ((T2CON & 0xff0f) | 0x0010);
	PR2=14740-1;
	IEC0bits.T2IE = 1;

	// Interrupt
	// Interrupt: Enable TMR3
	T3CON = ((T3CON & 0xfffd) | 0x8000);
	T3CON = ((T3CON & 0xff0f) | 0x0030);
	PR3=23030-1;
	IEC0bits.T3IE = 1;

	// Interrupt
	// Interrupt: Enable TMR4
	T4CON = ((T4CON & 0xfffd) | 0x8000);
	T4CON = ((T4CON & 0xff0f) | 0x0020);
	PR4=46000-1;
	IEC1bits.T4IE = 1;

	// Loop
	// Loop: While 1
	while (1)
	{


	}

	mainendloop: goto mainendloop;
	return 0;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/

	//Handler code for [TMR1]
	#ifndef MX_ISR_T1
	#define MX_ISR_T1
	void _ISR _T1Interrupt(void)
	{
		IFS0bits.T1IF = 0;
		FCM_Timer1_Interrupt();
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <Timer1_Interrupt> may never get called."
	#endif


	//Handler code for [TMR2]
	#ifndef MX_ISR_T2
	#define MX_ISR_T2
	void _ISR _T2Interrupt(void)
	{
		IFS0bits.T2IF = 0;
		FCM_Timer2_Interrupt();
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <Timer2_Interrupt> may never get called."
	#endif


	//Handler code for [TMR3]
	#ifndef MX_ISR_T3
	#define MX_ISR_T3
	void _ISR _T3Interrupt(void)
	{
		IFS0bits.T3IF = 0;
		FCM_timer3_interrupt();
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <timer3_interrupt> may never get called."
	#endif


	//Handler code for [TMR4]
	#ifndef MX_ISR_T4
	#define MX_ISR_T4
	void _ISR _T4Interrupt(void)
	{
		IFS1bits.T4IF = 0;
		FCM_ButtonInterrupt();
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <ButtonInterrupt> may never get called."
	#endif





